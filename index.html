<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Super Snake Deluxe - An advanced snake game with power-ups, achievements, and mini-games.">
    <title>Super Snake Deluxe</title>
    
    <!-- Inline favicon to prevent 404 errors -->
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA5ElEQVR4Ae3VMUoDQRTG8Tdi4QEsBAsLe8HWKwh2ghcQG0EPYCMIXsFSvICQE9h7A/EEdhYGQiLM82XYYiUZdwZhYOb7w6/YZvn2vZ09SNu2y5IvR6e0FcDx6GmS/wJolzF6dgGpAUoNoNQASg2gtGUAVVUdlWV5nuf5KdQz6ndF9NfYv/X0/4JpmqYHZl4CXgCfwAZoCuu+xnwDL8CD9gHuwQngGdj/BDAoOANeAe39vRvgDNgCLgFfmGfuXN8HXgBN2QlwBmzjawoBvoCH7L3vdH+my38Ae8C5UrbILZ7jI1xX+gXRiDb/l94nJQAAAABJRU5ErkJggg==">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- Inline CSS -->
    <style>
        :root {
            /* Define color theme using CSS variables */
            --bg-color: #1a1a2e;
            --primary-color: #00bcd4;
            --secondary-color: #ffeb3b;
            --accent-color: #ff4081;
            --food-color: #ff5252; /* Apple Red */
            --snake-head-color: #4caf50; /* Snake Head Green */
            --snake-head-gradient-end: #388e3c; /* Darker green for gradient */
            --snake-body-color: #8bc34a; /* Snake Body Light Green */
            --snake-body-gradient-end: #689f38; /* Darker light green */
            --obstacle-color: #795548; /* Obstacle Brown */
            --text-color: #e0e0e0;
            --border-color: #4dd0e1;
            --canvas-bg-color: #263238; /* Canvas Background */
            --canvas-grid-color: rgba(255,255,255,0.04); /* Grid lines */
            --highlight-bg-color: rgba(0, 188, 212, 0.3); /* Highlight Background */     
            --font-family: 'Press Start 2P', cursive;
            --mobile-button-bg: rgba(77, 208, 225, 0.6); /* Semi-transparent cyan */
            --mobile-button-active-bg: rgba(0, 188, 212, 0.8);
        }

        /* Basic reset and body styling */
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
            background: linear-gradient(45deg, var(--bg-color), #2c3e50);
            font-family: var(--font-family); color: var(--text-color);
            touch-action: manipulation; -webkit-tap-highlight-color: transparent;
        }
        body {
             display: flex; flex-direction: column; align-items: center;
             justify-content: space-around; padding-bottom: 100px; box-sizing: border-box;
        }
        h1 { color: var(--secondary-color); text-shadow: 2px 2px 0px var(--accent-color); margin-bottom: 10px; margin-top: 10px; font-size: 1.8em; }
        #game-area {
            position: relative; border: 5px solid var(--border-color); border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 188, 212, 0.6); background-color: var(--canvas-bg-color);
            background-image: linear-gradient(var(--canvas-grid-color) 1px, transparent 1px),
                              linear-gradient(90deg, var(--canvas-grid-color) 1px, transparent 1px);
            background-size: 20px 20px; width: 95vw; max-width: 800px; aspect-ratio: 1 / 1;
            margin-bottom: 10px;
        }
        canvas { display: block; border-radius: 10px; width: 100%; height: 100%; }
        #ui-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 95vw;
            max-width: 800px;
            margin-top: 0;
            margin-bottom: 10px;
            padding: 0 10px;
            box-sizing: border-box;
            position: relative;
        }
        #score {
            font-size: 1em;
            color: var(--secondary-color);
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #timer {
            font-size: 1em;
            color: var(--secondary-color);
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
        }

        /* Overlays - Using display for visibility */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.88); color: var(--text-color);
            display: none; /* Hidden by default */
            flex-direction: column; justify-content: center; align-items: center;
            border-radius: 10px; text-align: center; font-size: 1em; z-index: 10;
            padding: 15px; box-sizing: border-box;
        }
        .overlay.visible { display: flex; /* Show using flex */ }

        /* Overlay element sizing */
        .overlay h2 { color: var(--primary-color); margin-bottom: 15px; font-size: 1.3em; }
        .overlay p { margin-bottom: 15px; font-size: 0.9em;}
        .overlay input[type="text"], .overlay input[type="search"] { font-family: var(--font-family); font-size: 0.9em; padding: 10px; margin-bottom: 15px; border: 2px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color); border-radius: 5px; text-align: center; width: 80%; max-width: 250px; }
        .overlay input[type="text"]:focus, .overlay input[type="search"]:focus { outline: none; box-shadow: 0 0 10px var(--primary-color); }
        .overlay button { font-family: var(--font-family); font-size: 0.9em; padding: 10px 20px; margin-top: 10px; cursor: pointer; background: linear-gradient(45deg, var(--primary-color), var(--accent-color)); color: white; border: none; border-radius: 8px; box-shadow: 0 4px rgba(0, 0, 0, 0.3); transition: all 0.1s ease; text-transform: uppercase; }
        .overlay button:hover { filter: brightness(1.1); }
        .overlay button:active { box-shadow: 0 2px rgba(0, 0, 0, 0.3); transform: translateY(2px); }

        /* How to Play Button */
        #how-to-play-button { background: none; border: 1px solid var(--primary-color); color: var(--primary-color); padding: 5px 10px; margin-top: 5px; margin-bottom: 15px; border-radius: 5px; cursor: pointer; display: inline-flex; align-items: center; font-size: 0.8em; text-transform: none; box-shadow: none; transition: background-color 0.2s ease, color 0.2s ease; }
        #how-to-play-button svg { width: 16px; height: 16px; margin-right: 6px; stroke: currentColor; }
        #how-to-play-button:hover { background-color: rgba(0, 188, 212, 0.1); color: var(--border-color); }
        #how-to-play-button:active { transform: none; background-color: rgba(0, 188, 212, 0.2); }

        /* Instructions Text */
        #instructions-text { background-color: rgba(0, 0, 0, 0.2); border-radius: 5px; padding: 15px; margin-top: -10px; margin-bottom: 15px; width: 90%; max-width: 300px; box-sizing: border-box; text-align: left; font-size: 0.8em; line-height: 1.4; display: none; }
        #instructions-text ul { padding-left: 20px; margin-top: 5px; margin-bottom: 5px; }
        #instructions-text li { margin-bottom: 8px; }

        /* Leaderboard Specific */
        #leaderboard-overlay input[type="search"] { font-size: 0.8em; margin-bottom: 5px; max-width: 180px; }
        #leaderboard-notice { font-size: 0.65em; color: var(--text-color); opacity: 0.7; margin-top: 0; margin-bottom: 8px; font-style: italic; }
        #leaderboard-list { list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: auto; width: 90%; max-width: 300px; }
        #leaderboard-list li { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px dashed var(--primary-color); transition: background-color 0.3s ease; border-radius: 3px; font-size: 0.8em;}
        #leaderboard-list li:last-child { border-bottom: none; }
        #leaderboard-list .rank { color: var(--primary-color); margin-right: 8px; min-width: 1.8em; text-align: right;}
        #leaderboard-list .name { color: var(--secondary-color); text-align: left; flex-grow: 1; margin-right: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #leaderboard-list .score { color: var(--accent-color); text-align: right; }
        #leaderboard-list li.highlighted-rank { background-color: var(--highlight-bg-color); border-left: 3px solid var(--secondary-color); padding-left: 2px; }

        /* Search container for input and button */
        .leaderboard-search-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 5px;
            width: 90%;
            max-width: 240px;
        }
        .leaderboard-search-container input[type="search"] {
            margin-bottom: 0;
            flex-grow: 1;
        }
        #leaderboard-search-button {
            font-family: var(--font-family);
            font-size: 0.7em;
            padding: 9px 10px;
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 5px;
            box-shadow: 0 2px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #leaderboard-search-button svg {
            width: 16px;
            height: 16px;
        }
        #leaderboard-search-button:hover {
            filter: brightness(1.1);
        }
        #leaderboard-search-button:active {
            box-shadow: none;
            transform: translateY(1px);
        }

        /* Game Over Rank Info */
        #player-rank-info { color: var(--secondary-color); font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; min-height: 1.1em; }

        /* Snake Skins */
        .skin-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        .skin-option {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
        }
        .skin-option:hover {
            transform: scale(1.1);
        }
        .skin-option.selected {
            border-color: var(--secondary-color);
            box-shadow: 0 0 8px var(--secondary-color);
        }
        #skin-default {
            background: linear-gradient(45deg, var(--snake-body-color), var(--snake-head-color));
        }
        #skin-blue {
            background: linear-gradient(45deg, #64b5f6, #1976d2);
        }
        #skin-purple {
            background: linear-gradient(45deg, #ce93d8, #7b1fa2);
        }
        #skin-orange {
            background: linear-gradient(45deg, #ffb74d, #e65100);
        }

        /* Food Types & Power-ups Indicator */
        #power-up-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            color: var(--text-color);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #power-up-indicator.active {
            opacity: 1;
        }

        /* Speed Boost Button - positioned within UI container */
        #speed-boost-button {
            position: relative;
            top: 0;
            right: 0;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 5;
            transition: transform 0.2s, opacity 0.3s;
            opacity: 0;
        }

        @media (max-width: 500px) {
            #speed-boost-button {
                width: 40px;
                height: 40px;
                font-size: 1em;
            }
        }

        #speed-boost-button.visible {
            opacity: 1;
        }
        #speed-boost-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #speed-boost-button.cooldown {
            background: linear-gradient(45deg, #9e9e9e, #616161);
            cursor: not-allowed;
        }
        #speed-boost-button .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transition: height 0.1s linear;
        }
        
        /* Portal Styling - Enhanced */
        @keyframes portalPulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }
        @keyframes portalSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes portalGlow {
            0% { box-shadow: 0 0 5px 2px rgba(157, 39, 176, 0.5); }
            50% { box-shadow: 0 0 15px 5px rgba(157, 39, 176, 0.8); }
            100% { box-shadow: 0 0 5px 2px rgba(157, 39, 176, 0.5); }
        }

        /* Mobile Controls - Fixed Centering */
        #mobile-controls { 
            display: none; 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            padding: 15px 0; 
            background-color: rgba(0, 0, 0, 0.5); 
            z-index: 20; 
            pointer-events: none;
        }
        #mobile-controls.mobile-controls-visible { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        .d-pad { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr); 
            width: 170px; 
            height: 170px; 
            gap: 8px; 
            margin: 0 auto;
            pointer-events: auto;
        }
        .d-pad button { 
            font-family: var(--font-family); 
            font-size: 1.8em; 
            background-color: var(--mobile-button-bg); 
            border: 2px solid var(--border-color); 
            color: var(--text-color); 
            border-radius: 10px; 
            cursor: pointer; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            user-select: none; 
            transition: background-color 0.1s ease, transform 0.1s ease; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .d-pad button:active { 
            background-color: var(--mobile-button-active-bg); 
            transform: translateY(2px);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
        }
        #up-btn    { grid-column: 2; grid-row: 1; } #left-btn  { grid-column: 1; grid-row: 2; } #right-btn { grid-column: 3; grid-row: 2; } #down-btn  { grid-column: 2; grid-row: 3; }
        .d-pad-center { grid-column: 2; grid-row: 2; }

        #message-box { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); background-color: var(--accent-color); color: white; padding: 10px 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); z-index: 1000; font-size: 0.9em; opacity: 0; transition: opacity 0.5s ease-in-out, bottom 0.3s ease-in-out; }
        #message-box.visible { opacity: 1; bottom: 20px; }

        /* Footer */
        footer {
            margin-top: 20px;
            color: var(--text-color);
            font-size: 0.7em;
            text-align: center;
            opacity: 0.7;
        }

        /* Achievement Styling */
        .achievements-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            width: 90%;
            max-width: 400px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .achievement {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
            border: 2px solid var(--border-color);
        }

        .achievement.locked {
            filter: grayscale(1);
            opacity: 0.5;
        }

        .achievement-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .achievement-name {
            font-size: 0.8em;
            text-align: center;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 0.6em;
            text-align: center;
            color: #ccc;
        }

        .achievement-progress {
            width: 100%;
            height: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            margin-top: 8px;
            border-radius: 3px;
            overflow: hidden;
        }

        .achievement-progress-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Achievement Popup */
        #achievement-popup {
            position: fixed;
            bottom: -100px;
            right: 20px;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            color: white;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: bottom 0.5s ease;
            z-index: 1000;
            max-width: 300px;
            opacity: 0;
        }

        #achievement-popup.show {
            bottom: 20px;
            opacity: 1;
        }

        #achievement-popup .achievement-icon {
            font-size: 2.5em;
            margin-right: 15px;
            margin-bottom: 0;
        }

        #achievement-popup .achievement-content {
            flex: 1;
        }

        #achievement-popup .achievement-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        #achievement-popup .achievement-description {
            font-size: 0.8em;
            opacity: 0.9;
        }

        /* Mini-games Styling */
        .mini-game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            border-radius: 10px;
        }

        .mini-game-container.active {
            display: flex;
        }

        .mini-game-title {
            font-size: 1.2em;
            color: var(--secondary-color);
            margin-bottom: 20px;
        }

        .mini-game-instructions {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 20px;
            text-align: center;
            width: 80%;
        }

        .mini-game-area {
            width: 90%;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid var(--border-color);
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .mini-game-controls {
            display: flex;
            gap: 10px;
        }

        .mini-game-button {
            padding: 10px 15px;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            border: none;
            border-radius: 5px;
            color: white;
            font-family: var(--font-family);
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mini-game-button:hover {
            filter: brightness(1.1);
        }

        .mini-game-button:active {
            transform: scale(0.95);
        }

        /* Visual Effects */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .pulse {
            animation: pulse 0.5s ease;
        }

        .shake {
            animation: shake 0.5s ease;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
            will-change: transform, opacity;
        }

    </style>
    
    <!-- Inline manifest to avoid external file request -->
    <script>
        // Create and install the web manifest directly
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Create manifest data
                const manifestData = {
                    "name": "Super Snake Deluxe",
                    "short_name": "Snake",
                    "description": "An advanced snake game with power-ups and achievements",
                    "start_url": "./",
                    "display": "standalone",
                    "background_color": "#121212",
                    "theme_color": "#4CAF50",
                    "orientation": "portrait-primary",
                    "icons": [
                        {
                            "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA5ElEQVR4Ae3VMUoDQRTG8Tdi4QEsBAsLe8HWKwh2ghcQG0EPYCMIXsFSvICQE9h7A/EEdhYGQiLM82XYYiUZdwZhYOb7w6/YZvn2vZ09SNu2y5IvR6e0FcDx6GmS/wJolzF6dgGpAUoNoNQASg2gtGUAVVUdlWV5nuf5KdQz6ndF9NfYv/X0/4JpmqYHZl4CXgCfwAZoCuu+xnwDL8CD9gHuwQngGdj/BDAoOANeAe39vRvgDNgCLgFfmGfuXN8HXgBN2QlwBmzjawoBvoCH7L3vdH+my38Ae8C5UrbILZ7jI1xX+gXRiDb/l94nJQAAAABJRU5ErkJggg==",
                            "sizes": "64x64",
                            "type": "image/png"
                        }
                    ]
                };
                
                // Install the manifest
                const link = document.createElement('link');
                link.rel = 'manifest';
                
                // Create a blob and set it as the href
                const manifestBlob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
                link.href = URL.createObjectURL(manifestBlob);
                
                // Append to document
                document.head.appendChild(link);
                
                console.log("Manifest installed successfully");
            } catch (error) {
                console.error("Error setting up manifest:", error);
            }
        });
    </script>
    
    <!-- Global error handling for resources -->
    <script>
        window.addEventListener('error', function(e) {
            // Suppress console errors for resources that fail to load
            if (e.target.tagName === 'LINK' || e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG') {
                console.warn(`Resource loading error for ${e.target.src || e.target.href}`);
                e.preventDefault();
            }
        }, true);
    </script>
</head>
<body>
    <header>
    <h1>Super Snake Deluxe</h1>
    </header>

    <main>
    <div id="ui-container">
            <div id="score" aria-live="polite">Score: 0</div>
            <div id="timer" aria-live="polite">Time: 0s</div>
            <button id="speed-boost-button" aria-label="Speed Boost" title="Activate speed boost">
            <span>⚡</span>
            <div class="cooldown-overlay"></div>
        </button>
        </div>

        <div id="game-area" aria-label="Snake game board">
            <canvas id="gameCanvas" width="800" height="800" aria-label="Game canvas" role="img"></canvas>
            <div id="power-up-indicator" aria-live="polite"></div>

        <div id="username-overlay" class="overlay">
             <h2>Enter Your Name</h2>
             <p>For the Leaderboard!</p>
                 <input type="text" id="username-input" maxlength="10" placeholder="AAA" aria-label="Enter your username">
             
             <h3 style="font-size: 0.9em; margin-bottom: 5px; margin-top: 10px;">Choose Snake Skin</h3>
                 <div class="skin-selector" role="radiogroup" aria-label="Choose snake skin">
                    <div id="skin-default" class="skin-option selected" role="radio" aria-checked="true" tabindex="0" aria-label="Default green skin"></div>
                    <div id="skin-blue" class="skin-option" role="radio" aria-checked="false" tabindex="0" aria-label="Blue skin"></div>
                    <div id="skin-purple" class="skin-option" role="radio" aria-checked="false" tabindex="0" aria-label="Purple skin"></div>
                    <div id="skin-orange" class="skin-option" role="radio" aria-checked="false" tabindex="0" aria-label="Orange skin"></div>
             </div>
             
             <button id="how-to-play-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>How to Play?</button><div id="instructions-text"><ul><li>Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move the snake.</li><li>Eat the red apples <span style="color: var(--food-color)">●</span> to grow longer and score points!</li><li>Eat special foods for bonus points:</li><li>- Golden apples (20 points)</li><li>- Blueberries (5 points)</li><li>Collect power-ups for special abilities!</li><li>Use <strong>Portals</strong> to teleport across the board</li><li>Press the <strong>⚡</strong> button for a temporary speed boost</li><li>Avoid hitting the walls, your own body, or the brown blocks <span style="color: var(--obstacle-color)">■</span> (obstacles).</li><li>Get the highest score to make the Leaderboard!</li></ul></div><button id="start-game-button">Start Game</button><button id="show-leaderboard-button-start">View Leaderboard</button>
        </div>
        <div id="game-over-overlay" class="overlay">
            <h2>Game Over!</h2><div id="final-score" style="font-size: 1.2em; margin-bottom: 5px;">Score: 0</div><div id="player-rank-info"></div><button id="restart-button">Play Again</button><button id="show-leaderboard-button-gameover">View Leaderboard</button>
        </div>
        <div id="leaderboard-overlay" class="overlay">
            <h2>Leaderboard</h2>
            <div class="leaderboard-search-container">
                <input type="search" id="leaderboard-search" placeholder="Search rank...">
                <button id="leaderboard-search-button" aria-label="Search Leaderboard">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                </button>
            </div>
            <p id="leaderboard-notice">Aim for the highest score!</p>
            <ul id="leaderboard-list"><li>Loading...</li></ul> 
            <button id="close-leaderboard-button">Back</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad">
            <button id="up-btn">↑</button>
            <button id="left-btn">←</button>
            <div class="d-pad-center"></div> <button id="right-btn">→</button>
            <button id="down-btn">↓</button>
        </div>
    </div>

        <!-- Add Mini-Game Container -->
        <div id="mini-game-container" class="mini-game-container">
            <h3 class="mini-game-title">Apple Chase Challenge!</h3>
            <p class="mini-game-instructions">Tap/click as many apples as you can in 10 seconds!</p>
            <div class="mini-game-area" id="mini-game-area">
                <!-- Mini-game elements will be created here -->
            </div>
            <div class="mini-game-controls">
                <button class="mini-game-button" id="mini-game-start">Start</button>
                <button class="mini-game-button" id="mini-game-skip">Skip</button>
            </div>
        </div>

        <!-- Add Achievement System Overlay -->
        <div id="achievements-overlay" class="overlay">
            <h2>Achievements</h2>
            <div id="achievements-list" class="achievements-container">
                <!-- Achievements will be populated here -->
            </div>
            <button id="close-achievements-button">Back</button>
        </div>

        <!-- Add achievement indicator -->
        <div id="achievement-popup">
            <div class="achievement-icon">🏆</div>
            <div class="achievement-content">
                <div class="achievement-title">Achievement Unlocked!</div>
                <div class="achievement-description"></div>
        </div>
    </div>

    <div id="message-box"></div>
    </main>

    <footer>
        <p>Made with ❤️ by Viraj Shoor and Claude.</p>
    </footer>

    <script>
        // --- Enhanced Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameArea = document.getElementById('game-area');

        // UI Elements
        const scoreElement = document.getElementById('score');
        const usernameOverlay = document.getElementById('username-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const leaderboardOverlay = document.getElementById('leaderboard-overlay');
        const finalScoreElement = document.getElementById('final-score');
        const usernameInput = document.getElementById('username-input');
        const startGameButton = document.getElementById('start-game-button');
        const restartButton = document.getElementById('restart-button');
        const showLeaderboardButtonStart = document.getElementById('show-leaderboard-button-start');
        const showLeaderboardButtonGameOver = document.getElementById('show-leaderboard-button-gameover');
        const closeLeaderboardButton = document.getElementById('close-leaderboard-button');
        const leaderboardList = document.getElementById('leaderboard-list');
        const messageBox = document.getElementById('message-box');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const instructionsText = document.getElementById('instructions-text');
        const leaderboardSearchInput = document.getElementById('leaderboard-search');
        const playerRankInfo = document.getElementById('player-rank-info');
        const mobileControlsContainer = document.getElementById('mobile-controls');
        const upButton = document.getElementById('up-btn');
        const downButton = document.getElementById('down-btn');
        const leftButton = document.getElementById('left-btn');
        const rightButton = document.getElementById('right-btn');
        const leaderboardSearchButton = document.getElementById('leaderboard-search-button');

        // --- DEBUG: Check if overlay elements are found ---
        console.log("DEBUG: usernameOverlay element:", usernameOverlay);
        console.log("DEBUG: gameOverOverlay element:", gameOverOverlay);
        console.log("DEBUG: leaderboardOverlay element:", leaderboardOverlay);
        // --- End DEBUG ---

        // --- Color Variables --- (as before)
        const computedStyle = getComputedStyle(document.documentElement);
        const foodColor = computedStyle.getPropertyValue('--food-color').trim();
        const snakeHeadColor = computedStyle.getPropertyValue('--snake-head-color').trim();
        const snakeHeadGradientEnd = computedStyle.getPropertyValue('--snake-head-gradient-end').trim();
        const snakeBodyColor = computedStyle.getPropertyValue('--snake-body-color').trim();
        const snakeBodyGradientEnd = computedStyle.getPropertyValue('--snake-body-gradient-end').trim();
        const obstacleColor = computedStyle.getPropertyValue('--obstacle-color').trim();
        const canvasBgColor = computedStyle.getPropertyValue('--canvas-bg-color').trim();
        const canvasGridColor = computedStyle.getPropertyValue('--canvas-grid-color').trim();

        // Game Constants & State Variables
        const gridSize = 20; // Keep the cell size the same
        const canvasSize = 800; // Double the canvas size from 400 to 800
        const tileCount = canvasSize / gridSize; // Will now be 40 instead of 20
        let gameState = 'username'; 
        let snake, dx, dy, food, obstacles, score, gameSpeed, changingDirection, isGameOver, username;
        let highScore = 0;
        let eatSound, gameOverSound; 
        let audioReady = false;
        let lastUpdateTime = 0; 
        let accumulatedTime = 0; 
        let animationFrameId = null;
        let currentLeaderboardData = [];
        
        // Flag to prevent double-loading of leaderboard
        window.isLeaderboardFunctionCalling = false;

        // Portal colors definition
        const PORTAL_COLORS = [
            { primary: '#9C27B0', secondary: '#E1BEE7' }, // Purple
            { primary: '#2196F3', secondary: '#BBDEFB' }, // Blue
            { primary: '#FF9800', secondary: '#FFE0B2' }, // Orange
            { primary: '#4CAF50', secondary: '#C8E6C9' }, // Green
            { primary: '#F44336', secondary: '#FFCDD2' }  // Red
        ];

        // Power-up constants
        const POWER_UP_TYPES = [
            { type: 'shield', color: '#FFD700', effect: 'Shield', description: 'Shield: Temporary immunity to collisions' },
            { type: 'speed', color: '#2196F3', effect: 'Speed Boost', description: 'Speed: Move faster' },
            { type: 'slow', color: '#9C27B0', effect: 'Slow Motion', description: 'Slow: Move slower' },
            { type: 'ghost', color: '#B0BEC5', effect: 'Ghost Mode', description: 'Ghost: Pass through walls and body' },
            { type: 'magnet', color: '#F44336', effect: 'Food Magnet', description: 'Magnet: Attract food' },
            { type: 'shrink', color: '#4CAF50', effect: 'Shrink', description: 'Shrink: Reduce snake length' }
        ];
        const POWER_UP_SPAWN_CHANCE = 0.1; // 10% chance to spawn a power-up when generating food
        const POWER_UP_DURATION = 10000; // Power-up effects last for 10 seconds

        // Cooldown constants
        const PORTAL_COOLDOWN = 1500; // 1.5 seconds cooldown between portal uses
        const SPEED_BOOST_DURATION = 5000; // 5 seconds of speed boost
        const SPEED_BOOST_COOLDOWN = 10000; // 10 seconds cooldown for speed boost

        // Timer variables
        let gameStartTime = 0;
        let gameElapsedTime = 0;
        let finalTimeScore = 0;
        let timerElement = document.getElementById('timer');
        
        // New variables for the features
        let currentSkin = 'default';
        const skins = {
            default: {
                bodyColor: computedStyle.getPropertyValue('--snake-body-color').trim(),
                bodyGradientEnd: computedStyle.getPropertyValue('--snake-body-gradient-end').trim(),
                headColor: computedStyle.getPropertyValue('--snake-head-color').trim(),
                headGradientEnd: computedStyle.getPropertyValue('--snake-head-gradient-end').trim()
            },
            blue: {
                bodyColor: '#64b5f6',
                bodyGradientEnd: '#42a5f5',
                headColor: '#1976d2',
                headGradientEnd: '#0d47a1'
            },
            purple: {
                bodyColor: '#ce93d8',
                bodyGradientEnd: '#ba68c8',
                headColor: '#7b1fa2',
                headGradientEnd: '#4a148c'
            },
            orange: {
                bodyColor: '#ffb74d',
                bodyGradientEnd: '#ffa726',
                headColor: '#e65100',
                headGradientEnd: '#bf360c'
            },
            green: {
                bodyColor: '#81c784',
                bodyGradientEnd: '#66bb6a',
                headColor: '#388e3c',
                headGradientEnd: '#2e7d32'
            },
            red: {
                bodyColor: '#e57373',
                bodyGradientEnd: '#f44336',
                headColor: '#d32f2f',
                headGradientEnd: '#b71c1c'
            },
            yellow: {
                bodyColor: '#fff176',
                bodyGradientEnd: '#fff59d',
                headColor: '#f9a825',
                headGradientEnd: '#f57f17'
            }
        };

        
        // Mobile Controls State & Triple Tap Logic
        let mobileControlsVisible = false; let tapCount = 0; let lastTapTime = 0;
        let lastTapX = 0; let lastTapY = 0;
        const TAP_TIME_THRESHOLD = 300; const TAP_DISTANCE_THRESHOLD = 20;

        // --- API Endpoints ---
        const WORKER_URL = 'https://flat-mode-f83b.shoorviraj83.workers.dev'; // Your deployed worker URL
        const LOCAL_URL = window.location.origin; // Fallback to local server

        // Determine which API endpoints to use (will be set after checking)
        let LEADERBOARD_ENDPOINT = `${WORKER_URL}/api/leaderboard`;
        let SCORE_ENDPOINT = `${WORKER_URL}/api/scores`;

        // Function to check if the worker API is reachable
        async function checkApiEndpoint() {
            console.log("Checking if worker API is reachable...");
            
            try {
                // Send a HEAD request with a timeout to see if the API is responsive
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                
                const response = await fetch(`${WORKER_URL}/api/leaderboard`, {
                    method: 'HEAD',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                console.log(`API check response status: ${response.status}`);
                return response.ok;
            } catch (error) {
                console.error("Error checking API endpoint:", error);
                return false;
            }
        }

        async function loadLeaderboard() {
            leaderboardList.innerHTML = '<li>Loading...</li>';
            leaderboardSearchInput.disabled = true;
            
            try {
                // First check if the API is reachable
                const isApiReachable = await checkApiEndpoint();
                if (!isApiReachable) {
                    console.warn("Worker API not reachable, using local data");
                    throw new Error("API not reachable");
                }
                
                console.log("Fetching leaderboard from:", LEADERBOARD_ENDPOINT);
                
                // Use no-cors mode to avoid CORS issues
                const response = await fetch(LEADERBOARD_ENDPOINT, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json'
                        // Remove Cache-Control which is causing CORS issues
                    }
                });
                
                console.log("Leaderboard response status:", response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log("Leaderboard data received:", data);
                
                if (data && data.success && Array.isArray(data.results)) {
                    currentLeaderboardData = data.results;
                    return currentLeaderboardData;
                } else {
                    throw new Error("Invalid data format received from API");
                }
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                
                // Show a more helpful error message
                leaderboardList.innerHTML = `<li>Error loading scores! Using backup data</li>`;
                
                // Create a backup sample leaderboard when API fails
                console.log("Creating fallback leaderboard data");
                currentLeaderboardData = [
                    { name: "PLAYER1", score_value: 100, time_score: 120 },
                    { name: "PLAYER2", score_value: 80, time_score: 150 },
                    { name: "PLAYER3", score_value: 60, time_score: 200 },
                    { name: "PLAYER4", score_value: 40, time_score: 180 },
                    { name: "PLAYER5", score_value: 20, time_score: 220 }
                ];
                return currentLeaderboardData;
            }
        }

        async function saveScoreToAPI(name, currentScore, timeScore) {
            if (!name || currentScore <= 0) return;
            
            try {
                // First check if the API is reachable
                const isApiReachable = await checkApiEndpoint();
                if (!isApiReachable) {
                    console.warn("Worker API not reachable, score not saved");
                    showMessage("Network error - Score not saved", 3000);
                    return true; // Continue game flow regardless
                }
                
                // CRITICAL FIX: Ensure time_score is a valid INTEGER as expected by D1 database
                let validTimeScore = 0;
                
                if (timeScore === undefined || timeScore === null) {
                    console.warn("timeScore is undefined/null - using current game time");
                    // Use gameElapsedTime as fallback
                    validTimeScore = Math.max(1, Math.floor((Date.now() - gameStartTime) / 1000));
                } else if (typeof timeScore === 'number' && !isNaN(timeScore)) {
                    validTimeScore = Math.max(1, Math.floor(timeScore)); // Ensure it's a positive integer
                } else if (typeof timeScore === 'string') {
                    const parsed = parseInt(timeScore, 10);
                    validTimeScore = isNaN(parsed) ? 1 : Math.max(1, parsed);
                } else {
                    console.warn("Invalid timeScore type, using default of 1 second");
                    validTimeScore = 1; // Use 1 as minimum value instead of 0
                }
                
                console.log(`Saving score to API: ${name} - ${currentScore} - Time: ${validTimeScore}s`);
                console.log(`DEBUG: Original timeScore: type=${typeof timeScore}, value=${timeScore}, validTimeScore=${validTimeScore}`);
                
                // Ensure the API data follows the exact format expected by the D1 database
                const scoreData = {
                    name: name.toUpperCase().substring(0, 10),
                    score_value: parseInt(currentScore, 10), // Ensure this is an integer too
                    time_score: validTimeScore 
                };
                
                console.log(`DEBUG: Final score data being sent:`, JSON.stringify(scoreData, null, 2));
                
                // Use proper CORS mode for cross-origin requests
                const response = await fetch(SCORE_ENDPOINT, {
                    method: 'POST',
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(scoreData),
                });
                
                if (!response.ok) {
                    console.error(`Error saving score to API: ${response.status} ${response.statusText}`);
                    const errorText = await response.text().catch(() => "Could not read error response");
                    console.error("Error details:", errorText);
                    showMessage("Error saving score", 2000);
                    // Still continue even if save fails
                    return true;
                }
                
                const data = await response.json();
                console.log("Score save response:", data);
                
                if (data && data.success) {
                    showMessage("Score saved successfully!", 2000);
                    console.log("Time score successfully saved:", validTimeScore);
                }
                
                return true;
            } catch (error) {
                console.error("Network error when saving score:", error);
                showMessage("Network error - Score not saved", 3000);
                // Don't let API errors block the game
                return true;
            }
        }

        // --- Leaderboard API Functions ---
        async function displayLeaderboard() {
            console.log("Displaying leaderboard...");
            
            // Create a flag to prevent conflicts
            if (window.isDisplayingLeaderboard) {
                console.log("Leaderboard display already in progress, ignoring duplicate request");
                return;
            }
            
            // Set flags to prevent double loading and state transitions
            window.isLeaderboardFunctionCalling = true;
            window.isDisplayingLeaderboard = true;
            
            // Save the previous state to ensure we can return to it properly
            const previousState = gameState;
            
            // Ensure the leaderboard overlay is visible first
            switchState('leaderboard');
            
            try {
                showMessage("Loading leaderboard...", 2000);
                
                // Update UI to show loading state
                try {
                    const startButton = usernameOverlay.querySelector('#show-leaderboard-button-start');
                    const gameOverButton = gameOverOverlay.querySelector('#show-leaderboard-button-gameover');
                    
                    if (startButton) startButton.textContent = 'Loading...';
                    if (gameOverButton) gameOverButton.textContent = 'Loading...';
                } catch (btnError) {
                    console.error("Error updating button text:", btnError);
                }
                
                // Load data with timeout to prevent hanging
                let leaderboardPromise = loadLeaderboard();
                let timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error("Leaderboard load timeout")), 8000)
                );
                
                const board = await Promise.race([leaderboardPromise, timeoutPromise]);
                
                // Reset button text
                try {
                    const startButton = usernameOverlay.querySelector('#show-leaderboard-button-start');
                    const gameOverButton = gameOverOverlay.querySelector('#show-leaderboard-button-gameover');
                    
                    if (startButton) startButton.textContent = 'View Leaderboard';
                    if (gameOverButton) gameOverButton.textContent = 'View Leaderboard';
                } catch (btnError) {
                    console.error("Error resetting button text:", btnError);
                }
                
                // Ensure we're still on the leaderboard screen
                const leaderboardOverlay = document.getElementById('leaderboard-overlay');
                if (!leaderboardOverlay || !leaderboardOverlay.classList.contains('visible')) {
                    console.log("Leaderboard overlay not visible, re-showing it");
                    switchState('leaderboard');
                }
                
                // Clear the list and search input
                leaderboardList.innerHTML = '';
                leaderboardSearchInput.value = '';
                clearLeaderboardHighlight();
                
                console.log("Received leaderboard data:", board);
                
                if (!board || board.length === 0) {
                    console.log("No scores found in leaderboard data");
                    leaderboardList.innerHTML = '<li>No scores yet!</li>';
                    leaderboardSearchInput.disabled = true;
                } else {
                    leaderboardSearchInput.disabled = false;
                    
                    // Create and append all list items at once using a document fragment for better performance
                    const fragment = document.createDocumentFragment();
                    
                    board.forEach((entry, index) => {
                        const li = document.createElement('li');
                        const rank = index + 1;
                        const safeName = String(entry.name || '???').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        const safeScore = parseInt(entry.score_value || 0);
                        
                        // Add more detailed logging for time_score debugging
                        console.log(`Entry ${index} (${safeName}): Raw time_score:`, 
                                    entry.time_score, 
                                    `Type: ${typeof entry.time_score}`,
                                    `ParsedInt: ${parseInt(entry.time_score || 0)}`);
                        
                        const timeScore = parseInt(entry.time_score || 0);
                        
                        let timeDisplay = '';
                        if (timeScore > 0) {
                            timeDisplay = ` (${formatTime(timeScore)})`;
                            console.log(`Formatted time for ${safeName}: ${formatTime(timeScore)}`);
                        } else {
                            console.warn(`No time score (or zero) for ${safeName}`);
                        }
                        
                        li.innerHTML = `
                            <span class="rank">#${rank}</span>
                            <span class="name">${safeName}</span>
                            <span class="score">${safeScore}${timeDisplay}</span>
                        `;
                        
                        fragment.appendChild(li);
                    });
                    
                    // Append all entries at once
                    leaderboardList.appendChild(fragment);
                    
                    // Highlight player score if available
                    if (username) {
                        // Look for the player in the leaderboard (case insensitive)
                        const upperUsername = username.toUpperCase().substring(0, 10);
                        const playerEntry = board.find(entry => entry.name === upperUsername);
                        
                        if (playerEntry) {
                            const playerRank = board.indexOf(playerEntry);
                            console.log(`Found player at rank ${playerRank + 1} with score ${playerEntry.score_value}`);
                            
                            setTimeout(() => {
                                const items = leaderboardList.querySelectorAll('li');
                                if (items[playerRank]) {
                                    items[playerRank].classList.add('highlighted-rank');
                                    items[playerRank].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                }
                            }, 100);
                        }
                    }
                }
            } catch (e) {
                console.error("Error in displayLeaderboard:", e);
                
                // Reset button text
                try {
                    const startButton = usernameOverlay.querySelector('#show-leaderboard-button-start');
                    const gameOverButton = gameOverOverlay.querySelector('#show-leaderboard-button-gameover');
                    
                    if (startButton) startButton.textContent = 'View Leaderboard';
                    if (gameOverButton) gameOverButton.textContent = 'View Leaderboard';
                } catch (btnError) {
                    console.error("Error resetting button text:", btnError);
                }
                
                // Make sure we always show something in the leaderboard
                leaderboardList.innerHTML = '<li>Error showing scores. Try again later.</li>';
            } finally {
                // Reset flags to allow normal operation again
                window.isLeaderboardFunctionCalling = false;
                
                // Wait a moment before allowing new leaderboard requests
                setTimeout(() => {
                    window.isDisplayingLeaderboard = false;
                }, 500);
            }
        }
        function clearLeaderboardHighlight() { /* ... */ const items = leaderboardList.querySelectorAll('li'); items.forEach(item => item.classList.remove('highlighted-rank')); }
        function handleLeaderboardSearch() { /* ... */ clearLeaderboardHighlight(); const rankToFind = parseInt(leaderboardSearchInput.value.trim()); const items = leaderboardList.querySelectorAll('li'); if (!isNaN(rankToFind) && rankToFind >= 1 && rankToFind <= items.length && !items[0].textContent.includes('Loading') && !items[0].textContent.includes('Error')) { const targetItem = items[rankToFind - 1]; if (targetItem) { targetItem.classList.add('highlighted-rank'); targetItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } } else if (leaderboardSearchInput.value.trim() !== '') { showMessage("Invalid rank.", 1500); leaderboardSearchInput.value = ''; } }
        function displayPlayerRank() { /* ... */ playerRankInfo.textContent = ''; if (score <= 0 || currentLeaderboardData.length === 0) return; const currentName = (username || 'AAA').toUpperCase().substring(0, 10); const playerIndex = currentLeaderboardData.findIndex(entry => entry.name === currentName && entry.score_value === score); if (playerIndex > -1) { const rank = playerIndex + 1; playerRankInfo.textContent = `You ranked #${rank}!`; } }

        /** Initializes or resets game variables */
        function initGameVariables() {
            snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }]; 
            dx = 0; dy = 0; changingDirection = false; score = 0; 
            gameSpeed = isTouchDevice() ? 350 : 150; // Slower game speed on mobile
            normalGameSpeed = gameSpeed; // Store normal speed for boost feature
            isGameOver = false; 
            
            // Load high score from localStorage
            highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
            
            // Reset timer
            gameStartTime = Date.now();
            gameElapsedTime = 0;
            finalTimeScore = 0;
            updateTimerDisplay();
            
            // Reset food, power-ups and obstacles
            food = { x: -1, y: -1, type: 'regular' }; 
            powerUps = [];
            activePowerUp = null;
            powerUpTimer = 0;
            updatePowerUpIndicator();
            
            // Reset portals
            portals = [];
            generatePortalPair();
            portalCooldown = false;
            lastPortalUsed = null;
            
            // Reset speed boost
            speedBoostActive = false;
            speedBoostCooldown = false;
            speedBoostTimer = 0;
            updateSpeedBoostButton();
            
            obstacles = []; 
            playerRankInfo.textContent = ''; lastUpdateTime = 0; accumulatedTime = 0; 
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } 
            try { 
                generateFood(); 
                obstacles = generateObstacles(10); 
            } catch (e) { 
                console.error("Error generating obstacles or food:", e); 
                showMessage("Error setting up board! Retrying...", 2000); 
                // Don't throw the error, handle it gracefully
                obstacles = []; // Ensure obstacles is an array even if generation failed
                
                // Try again with fewer obstacles
                try {
                    generateFood();
                    obstacles = generateObstacles(5);
                } catch (innerError) {
                    console.error("Second attempt to generate obstacles failed:", innerError);
                    obstacles = []; // Just use no obstacles rather than breaking the game
                }
            } 
            updateScoreDisplay(); 
        }

        // --- Drawing Functions --- (With Gradients - unchanged)
        function clearCanvas() { ctx.fillStyle = canvasBgColor; ctx.fillRect(0, 0, canvasSize, canvasSize); ctx.fillStyle = canvasGridColor; for (let i = 1; i < tileCount; i++) { ctx.fillRect(i * gridSize - 0.5, 0, 1, canvasSize); ctx.fillRect(0, i * gridSize - 0.5, canvasSize, 1); } }
        function drawSnakePart(segment, index) { 
            const x = segment.x * gridSize; 
            const y = segment.y * gridSize; 
            const r = gridSize * 0.3; 
            const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize); 
            
            // Use the selected skin colors
            gradient.addColorStop(0, skins[currentSkin].bodyColor); 
            gradient.addColorStop(1, skins[currentSkin].bodyGradientEnd); 
            
            ctx.fillStyle = gradient; 
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; 
            ctx.beginPath(); 
            ctx.roundRect(x + 1, y + 1, gridSize - 2, gridSize - 2, r); 
            ctx.fill(); 
            ctx.stroke(); 
        }
        
        function drawSnakeHead(head) { 
            const x = head.x * gridSize; 
            const y = head.y * gridSize; 
            const r = gridSize * 0.3; 
            const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize); 
            
            // Use the selected skin colors
            gradient.addColorStop(0, skins[currentSkin].headColor); 
            gradient.addColorStop(1, skins[currentSkin].headGradientEnd); 
            
            ctx.fillStyle = gradient; 
            ctx.strokeStyle = 'rgba(0,0,0,0.5)'; 
            ctx.beginPath(); 
            ctx.roundRect(x + 1, y + 1, gridSize - 2, gridSize - 2, r); 
            ctx.fill(); 
            ctx.stroke(); 
            
            // Draw eyes
            ctx.fillStyle = '#FFFFFF'; 
            const eyeSize = gridSize / 6; 
            const pupilSize = eyeSize / 2; 
            let e1X, e1Y, e2X, e2Y, p1X, p1Y, p2X, p2Y; 
            const o = gridSize * 0.25; 
            
            if (dx === 1) { e1X = x + gridSize * 0.6; e1Y = y + o; e2X = x + gridSize * 0.6; e2Y = y + gridSize - o - eyeSize; p1X = e1X + eyeSize / 2; p1Y = e1Y; p2X = e2X + eyeSize / 2; p2Y = e2Y; } 
            else if (dx === -1) { e1X = x + gridSize * 0.4 - eyeSize; e1Y = y + o; e2X = x + gridSize * 0.4 - eyeSize; e2Y = y + gridSize - o - eyeSize; p1X = e1X - eyeSize / 2; p1Y = e1Y; p2X = e2X - eyeSize / 2; p2Y = e2Y; } 
            else if (dy === 1) { e1X = x + o; e1Y = y + gridSize * 0.6; e2X = x + gridSize - o - eyeSize; e2Y = y + gridSize * 0.6; p1X = e1X; p1Y = e1Y + eyeSize / 2; p2X = e2X; p2Y = e2Y + eyeSize / 2; } 
            else { e1X = x + o; e1Y = y + gridSize * 0.4 - eyeSize; e2X = x + gridSize - o - eyeSize; e2Y = y + gridSize * 0.4 - eyeSize; p1X = e1X; p1Y = e1Y - eyeSize / 2; p2X = e2X; p2Y = e2Y - eyeSize / 2; } 
            
            ctx.beginPath(); 
            ctx.arc(e1X + eyeSize / 2, e1Y + eyeSize / 2, eyeSize, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.beginPath(); 
            ctx.arc(e2X + eyeSize / 2, e2Y + eyeSize / 2, eyeSize, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.fillStyle = '#000000'; 
            ctx.beginPath(); 
            ctx.arc(p1X + pupilSize, p1Y + pupilSize, pupilSize, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.beginPath(); 
            ctx.arc(p2X + pupilSize, p2Y + pupilSize, pupilSize, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        function drawSnake() { snake.forEach((seg, i) => { if (i === 0) drawSnakeHead(seg); else drawSnakePart(seg, i); }); }
        function drawFood() { 
            const r = gridSize / 2; 
            const x = food.x * gridSize + r; 
            const y = food.y * gridSize + r; 
            const p = Math.sin(Date.now() * 0.01) * 0.05 + 0.9; 
            
            // Different food types
            switch(food.type) {
                case 'golden':
                    // Golden apple
                    ctx.fillStyle = '#FFD700'; 
                    ctx.beginPath(); 
                    ctx.arc(x, y, r * p, 0, Math.PI * 2); 
                    ctx.fill(); 
                    
                    // Sparkle effect
                    ctx.strokeStyle = '#FFF9C4';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2) + (Date.now() * 0.002);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * r * 1.5, y + Math.sin(angle) * r * 1.5);
                        ctx.stroke();
                    }
                    break;
                    
                case 'small':
                    // Blueberry (smaller, worth fewer points)
                    ctx.fillStyle = '#3F51B5'; 
                    ctx.beginPath(); 
                    ctx.arc(x, y, r * p * 0.7, 0, Math.PI * 2); 
                    ctx.fill(); 
                    break;
                    
                case 'regular':
                default:
                    // Regular red apple
                    ctx.fillStyle = foodColor; 
                    ctx.beginPath(); 
                    ctx.arc(x, y, r * p, 0, Math.PI * 2); 
                    ctx.fill(); 
                    
                    // Stem
                    ctx.fillStyle = snakeHeadColor; 
                    const sw = gridSize * 0.15; 
                    const sh = gridSize * 0.3; 
                    ctx.fillRect(x - sw / 2, y - r * p - sh + 3, sw, sh); 
                    
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; 
                    ctx.beginPath(); 
                    ctx.arc(x - r * 0.3, y - r * 0.4, r * 0.2 * p, 0, Math.PI * 2); 
                    ctx.fill();
                    break;
            }
        }
        function drawObstacles() { /* ... */ ctx.fillStyle = obstacleColor; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; obstacles.forEach(o => { const x = o.x * gridSize; const y = o.y * gridSize; ctx.beginPath(); ctx.roundRect(x + 2, y + 2, gridSize - 4, gridSize - 4, gridSize * 0.1); ctx.fill(); ctx.stroke(); }); }
        
        // Draw portals - Enhanced
        function drawPortals() {
            if (!portals.length) return;
            
            portals.forEach((portal, index) => {
                const x = portal.x * gridSize;
                const y = portal.y * gridSize;
                const colors = PORTAL_COLORS[portal.pair];
                
                // Save current context state
                ctx.save();
                
                // Portal outer glow (larger and more visible)
                const gradient = ctx.createRadialGradient(
                    x + gridSize/2, y + gridSize/2, gridSize/6,
                    x + gridSize/2, y + gridSize/2, gridSize*1.2
                );
                gradient.addColorStop(0, colors.primary);
                gradient.addColorStop(0.6, colors.primary + '80'); // Semi-transparent
                gradient.addColorStop(1, 'transparent');
                
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + gridSize/2, y + gridSize/2, gridSize*1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Portal ring (thicker)
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = colors.primary;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x + gridSize/2, y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                ctx.stroke();
                
                // Portal inner fill (brighter)
                ctx.fillStyle = colors.secondary;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(x + gridSize/2, y + gridSize/2, gridSize/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Portal swirl effect (more visible)
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = colors.primary;
                ctx.lineWidth = 2;
                
                // Create spinning effect with current time
                const rotation = (Date.now() * 0.004) % (Math.PI * 2);
                const lines = 8; // More lines for better visibility
                
                for (let i = 0; i < lines; i++) {
                    const angle = (i / lines) * Math.PI * 2 + rotation;
                    const innerRadius = gridSize/6;
                    const outerRadius = gridSize/2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x + gridSize/2 + Math.cos(angle) * innerRadius,
                        y + gridSize/2 + Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        x + gridSize/2 + Math.cos(angle) * outerRadius,
                        y + gridSize/2 + Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
                
                // Add center dot
                ctx.fillStyle = '#FFFFFF';
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.beginPath();
                ctx.arc(x + gridSize/2, y + gridSize/2, gridSize/10, 0, Math.PI * 2);
                ctx.fill();
                
                // Restore context
                ctx.restore();
            });
        }

        // --- Game Logic --- (Generation, Movement, Collision - unchanged)
        function moveSnake() { 
            if (dx === 0 && dy === 0) return; 
            
            const head = { x: snake[0].x + dx, y: snake[0].y + dy }; 
            
            // Check for portal teleportation
            const portalEntered = checkPortalTeleport(head);
            if (portalEntered) {
                // Update achievement for portal usage
                updateAchievement('portal_master', 1);
                
                // If teleported, update the head position
                head.x = portalEntered.x;
                head.y = portalEntered.y;
            }
            
            snake.unshift(head); 
            
            // Handle magnet power-up
            if (activePowerUp && activePowerUp.type === 'magnet') {
                handleMagnetPowerUp(head);
            }
            
            if (head.x === food.x && head.y === food.y) { 
                handleFoodCollision(head);
            } else { 
                snake.pop(); 
            } 
            
            // Check for power-up collection
            checkPowerUpCollected();
            // Check if active power-up has expired
            checkPowerUpExpiry();
            // Check speed boost status
            checkSpeedBoostStatus();
        }
        function generateObstacles(count) { /* ... */ const newObstacles = []; const occupied = [...(snake || []), ...(food && food.x !== -1 ? [food] : [])]; let attempts = 0; while (newObstacles.length < count && attempts < tileCount * tileCount) { const obsX = Math.floor(Math.random() * tileCount); const obsY = Math.floor(Math.random() * tileCount); const isOccupied = occupied.some(p => p.x === obsX && p.y === obsY) || newObstacles.some(o => o.x === obsX && o.y === obsY) || obsX < 1 || obsX >= tileCount - 1 || obsY < 1 || obsY >= tileCount - 1 || (obsX > tileCount*0.4 && obsX < tileCount*0.6 && obsY > tileCount*0.4 && obsY < tileCount*0.6); if (!isOccupied) { newObstacles.push({ x: obsX, y: obsY }); occupied.push({ x: obsX, y: obsY }); } attempts++; } if(attempts >= tileCount * tileCount) console.warn("Could not generate all obstacles."); return newObstacles; }
        function generateFood() { 
            const occupied = [...(snake || []), ...(obstacles || []), ...(powerUps || [])]; 
            let attempts = 0; 
            
            while (attempts < tileCount * tileCount) { 
                food = { 
                    x: Math.floor(Math.random() * tileCount), 
                    y: Math.floor(Math.random() * tileCount),
                    type: selectRandomFoodType()
                }; 
                
                let collision = occupied.some(p => p.x === food.x && p.y === food.y); 
                if (!collision) break; 
                attempts++; 
            } 
            
            // Chance to spawn a power-up
            if (Math.random() < POWER_UP_SPAWN_CHANCE) {
                generatePowerUp();
            }
            
            if(attempts >= tileCount * tileCount) console.warn("Could not generate food."); 
        }
        function selectRandomFoodType() {
            const rand = Math.random();
            if (rand < 0.1) {
                return 'golden';  // 10% chance of golden apple (high value)
            } else if (rand < 0.3) {
                return 'small';   // 20% chance of small food (low value)
            } else {
                return 'regular'; // 70% chance of regular food
            }
        }
        
        function generatePowerUp() {
            if (powerUps.length >= 1) return; // Limit to one power-up at a time
            
            const occupied = [...(snake || []), ...(obstacles || []), food ? [food] : []];
            let attempts = 0;
            
            // Choose random power-up type
            const powerUpType = POWER_UP_TYPES[Math.floor(Math.random() * POWER_UP_TYPES.length)];
            
            // Find valid position
            while (attempts < 50) {
                const powerUp = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: powerUpType.type,
                    color: powerUpType.color,
                    effect: powerUpType.effect,
                    description: powerUpType.description
                };
                
                let collision = occupied.some(p => p.x === powerUp.x && p.y === powerUp.y);
                if (!collision) {
                    powerUps.push(powerUp);
                    break;
                }
                attempts++;
            }
        }
        
        function updatePowerUpIndicator() {
            const indicator = document.getElementById('power-up-indicator');
            if (!indicator) return;
            
            if (activePowerUp) {
                indicator.textContent = activePowerUp.description;
                indicator.classList.add('active');
            } else {
                indicator.textContent = '';
                indicator.classList.remove('active');
            }
        }
        
        function applyPowerUpEffect(powerUp) {
            activePowerUp = powerUp;
            powerUpTimer = Date.now() + POWER_UP_DURATION;
            
            // Apply effects
            switch(powerUp.type) {
                case 'shield':
                    // Immunity - handled in checkGameOver()
                    break;
                case 'speed':
                    gameSpeed = Math.max(40, gameSpeed * 0.6); // Faster
                    break;
                case 'slow':
                    gameSpeed = gameSpeed * 1.5; // Slower
                    break;
                case 'ghost':
                    // Ghost mode - handled in checkGameOver() and draw functions
                    // Will allow passing through walls and own body
                    break;
                case 'magnet':
                    // Magnet effect - implemented in moveSnake()
                    break;
                case 'shrink':
                    // Shrink the snake by removing the last 3 segments (or half, whichever is less)
                    const segmentsToRemove = Math.min(3, Math.floor(snake.length / 2));
                    if (snake.length > segmentsToRemove) {
                        snake.splice(snake.length - segmentsToRemove, segmentsToRemove);
                    }
                    break;
            }
            
            updatePowerUpIndicator();
            showMessage(`${powerUp.effect} activated!`, 2000);
            
            // Add visual effect
            gameArea.classList.add('pulse');
            setTimeout(() => gameArea.classList.remove('pulse'), 500);
        }
        
        function checkPowerUpCollected() {
            if (!powerUps.length || !snake.length) return;
            
            const head = snake[0];
            const powerUpIndex = powerUps.findIndex(p => p.x === head.x && p.y === head.y);
            
            if (powerUpIndex !== -1) {
                const powerUp = powerUps[powerUpIndex];
                applyPowerUpEffect(powerUp);
                powerUps.splice(powerUpIndex, 1);
                playEatSound(); // Use same sound for now
            }
        }
        
        function checkPowerUpExpiry() {
            if (!activePowerUp) return;
            
            if (Date.now() >= powerUpTimer) {
                // Reset effects
                if (activePowerUp.type === 'speed') {
                    gameSpeed = isTouchDevice() ? 350 : 150; // Reset to normal
                } else if (activePowerUp.type === 'slow') {
                    gameSpeed = isTouchDevice() ? 350 : 150; // Reset to normal
                }
                
                activePowerUp = null;
                updatePowerUpIndicator();
            }
        }

        function checkGameOver() { 
            const head = snake[0]; 
            if (!head) return true; 
            
            // If shield power-up is active or ghost mode, no collision death
            if (activePowerUp && (activePowerUp.type === 'shield' || activePowerUp.type === 'ghost')) {
                // Still need to check if snake is on the board
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    // Just wrap around the board for ghost mode
                    if (activePowerUp.type === 'ghost') {
                        if (head.x < 0) head.x = tileCount - 1;
                        if (head.x >= tileCount) head.x = 0;
                        if (head.y < 0) head.y = tileCount - 1;
                        if (head.y >= tileCount) head.y = 0;
                    } else {
                        // For shield, just stop at edges
                    if (head.x < 0) head.x = 0;
                    if (head.x >= tileCount) head.x = tileCount - 1;
                    if (head.y < 0) head.y = 0;
                    if (head.y >= tileCount) head.y = tileCount - 1;
                    }
                    return false;
                }
                return false; // No death with shield or ghost
            }
            
            // Standard collision checks
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) return true; 
            
            for (let i = 1; i < snake.length; i++) { 
                if (head.x === snake[i].x && head.y === snake[i].y) return true; 
            } 
            
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) return true; 
            
            return false; 
        }

        /** Sets the snake's direction, preventing 180 turns */
        function setDirection(newDx, newDy) { /* ... */ if (gameState !== 'playing' || changingDirection) return; const goingUp = dy === -1; const goingDown = dy === 1; const goingRight = dx === 1; const goingLeft = dx === -1; if ((newDx === -1 && goingRight) || (newDx === 1 && goingLeft) || (newDy === -1 && goingDown) || (newDy === 1 && goingUp)) { if (dx === 0 && dy === 0) {} else { return; } } dx = newDx; dy = newDy; changingDirection = true; }
        /** Handles keyboard input */
        function handleKeyDown(event) { /* ... */ const LEFT_KEY = 37; const RIGHT_KEY = 39; const UP_KEY = 38; const DOWN_KEY = 40; const A_KEY = 65; const D_KEY = 68; const W_KEY = 87; const S_KEY = 83; const keyPressed = event.keyCode; if (keyPressed === LEFT_KEY || keyPressed === A_KEY) setDirection(-1, 0); else if (keyPressed === UP_KEY || keyPressed === W_KEY) setDirection(0, -1); else if (keyPressed === RIGHT_KEY || keyPressed === D_KEY) setDirection(1, 0); else if (keyPressed === DOWN_KEY || keyPressed === S_KEY) setDirection(0, 1); }
        function updateScoreDisplay() { scoreElement.textContent = `Score: ${score}`; }
        function showMessage(message, duration = 2000) { messageBox.textContent = message; messageBox.classList.add('visible'); setTimeout(() => { messageBox.classList.remove('visible'); }, duration); }

        /** Manages game state transitions and overlay visibility */
        function switchState(state) {
            try {
                console.log(`Switching state: ${gameState} -> ${state}`);
                
                // Only update gameState when switching to a new, different state
                if (gameState !== state) {
                    gameState = state;
                }
                
                // Hide all containers
                try {
                    const allContainers = document.querySelectorAll('.game-container, .overlay');
                    allContainers.forEach(container => {
                        if (container.classList.contains('overlay')) {
                            container.classList.remove('visible');
                        } else {
                            container.style.display = 'none';
                        }
                    });
                } catch (e) {
                    console.error("Error hiding containers:", e);
                }
                
                // Show the relevant UI for the current state
                switch (state) {
                    case 'username':
                        try {
                            const usernameOverlay = document.getElementById('username-overlay');
                            if (usernameOverlay) {
                                usernameOverlay.classList.add('visible');
                                const usernameInput = document.getElementById('username-input');
                                if (usernameInput) usernameInput.focus();
                            } else {
                                console.error("username-overlay element not found");
                            }
                        } catch (e) {
                            console.error("Error showing username overlay:", e);
                        }
                        break;
                        
                    case 'menu':
                        try {
                            const menuOverlay = document.getElementById('menu-overlay');
                            if (menuOverlay) {
                                menuOverlay.classList.add('visible');
                            } else {
                                console.error("menu-overlay element not found");
                            }
                        } catch (e) {
                            console.error("Error showing menu overlay:", e);
                        }
                        break;
                        
                    case 'playing':
                        try {
                            const gameArea = document.getElementById('game-area');
                            if (gameArea) {
                                gameArea.style.display = 'block';
                                
                                // Initialize and start the game
                                try {
                                    initGameVariables();
                                    startGameLoop();
                                } catch (err) {
                                    console.error("Error starting game:", err);
                                }
                            } else {
                                console.error("game-area element not found");
                            }
                        } catch (e) {
                            console.error("Error showing game area:", e);
                        }
                        break;
                        
                    case 'paused':
                        try {
                            const gameArea = document.getElementById('game-area');
                            const pauseOverlay = document.getElementById('pause-overlay');
                            
                            if (gameArea) gameArea.style.display = 'block';
                            if (pauseOverlay) pauseOverlay.classList.add('visible');
                        } catch (e) {
                            console.error("Error showing pause overlay:", e);
                        }
                        break;
                        
                    case 'gameover':
                        try {
                            const gameArea = document.getElementById('game-area');
                            const gameOverOverlay = document.getElementById('game-over-overlay');
                            const finalScore = document.getElementById('final-score');
                            
                            if (gameArea) gameArea.style.display = 'block';
                            if (gameOverOverlay) gameOverOverlay.classList.add('visible');
                            if (finalScore) finalScore.textContent = `Score: ${score}`;
                        } catch (e) {
                            console.error("Error showing game over overlay:", e);
                        }
                        break;
                        
                    case 'leaderboard':
                        try {
                            // Show the leaderboard overlay
                            console.log("Switching to leaderboard state");
                            const leaderboardOverlay = document.getElementById('leaderboard-overlay');
                            
                            if (leaderboardOverlay) {
                                leaderboardOverlay.classList.add('visible');
                                
                                // Only load leaderboard data if we're not coming from displayLeaderboard
                                if (!window.isLeaderboardFunctionCalling) {
                                    // Load fresh leaderboard data when showing the leaderboard
                                    console.log("Loading fresh leaderboard data from switchState...");
                                    
                                    loadLeaderboard()
                                        .then(data => {
                                            clearLeaderboardHighlight();
                                            
                                            // Highlight the player's score if it exists
                                            if (username && score > 0) {
                                                const playerRank = data.findIndex(entry => 
                                                    entry.name === username.toUpperCase().substring(0, 10) && 
                                                    entry.score_value === score
                                                );
                                                
                                                if (playerRank >= 0) {
                                                    console.log(`Found player at rank ${playerRank + 1}`);
                                                    setTimeout(() => {
                                                        const items = document.querySelectorAll('#leaderboard-list li');
                                                        if (items[playerRank]) {
                                                            items[playerRank].classList.add('highlighted-rank');
                                                            items[playerRank].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                                        }
                                                    }, 100);
                                                }
                                            }
                                        })
                                        .catch(err => {
                                            console.error("Error loading leaderboard from switchState:", err);
                                        });
                                } else {
                                    console.log("Skipping leaderboard load from switchState as displayLeaderboard is already handling it");
                                }
                            } else {
                                console.error("leaderboard-overlay element not found");
                            }
                        } catch (e) {
                            console.error("Error showing leaderboard overlay:", e);
                        }
                        break;
                        
                    case 'achievements':
                        try {
                            const achievementsOverlay = document.getElementById('achievements-overlay');
                            if (achievementsOverlay) {
                                achievementsOverlay.classList.add('visible');
                            } else {
                                console.error("achievements-overlay element not found");
                            }
                        } catch (e) {
                            console.error("Error showing achievements overlay:", e);
                        }
                        break;
                        
                    case 'options':
                        try {
                            const optionsOverlay = document.getElementById('options-overlay');
                            if (optionsOverlay) {
                                optionsOverlay.classList.add('visible');
                            } else {
                                console.error("options-overlay element not found");
                            }
                        } catch (e) {
                            console.error("Error showing options overlay:", e);
                        }
                        break;
                        
                    default:
                        console.error(`Unknown game state: ${state}`);
                        try {
                            const menuOverlay = document.getElementById('menu-overlay');
                            if (menuOverlay) menuOverlay.classList.add('visible');
                        } catch (e) {
                            console.error("Error showing fallback menu overlay:", e);
                        }
                }
                
                // Update UI based on state change
                try {
            updateSpeedBoostButton();
                } catch (e) {
                    console.error("Error updating speed boost button:", e);
                }
            } catch (e) {
                console.error(`Critical error in switchState('${state}'):`, e);
            }
        }

        // --- Main Game Loop (Using requestAnimationFrame) ---
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;
            
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            const deltaTime = timestamp - lastUpdateTime;
            lastUpdateTime = timestamp;
            
            accumulatedTime += deltaTime;
            
            // Update the timer every frame, regardless of snake movement
            updateTimerDisplay();
            
            // Check if enough time has passed to update the game state
            if (accumulatedTime >= gameSpeed) {
                moveSnake();
                
                if (checkGameOver()) {
                    handleGameOver();
                    return;
                }
                
                clearCanvas();
                drawObstacles();
                drawPortals();
                drawFood();
                drawSnake();
                drawPowerUps();
                
                accumulatedTime = 0;
                changingDirection = false;
            }
            
            // Continue the game loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function startGameLoop() { lastUpdateTime = 0; accumulatedTime = 0; if (animationFrameId) { cancelAnimationFrame(animationFrameId); } animationFrameId = requestAnimationFrame(gameLoop); }

        // --- Mobile Controls & Detection ---
        function isTouchDevice() {
            try {
                return (('ontouchstart' in window) ||
                    (navigator.maxTouchPoints > 0) ||
                    (navigator.msMaxTouchPoints > 0));
            } catch (e) {
                console.error("Error detecting touch device:", e);
                return false;
            }
        }
        function toggleMobileControls() { mobileControlsVisible = !mobileControlsVisible; if (mobileControlsVisible) { mobileControlsContainer.classList.add('mobile-controls-visible'); } else { mobileControlsContainer.classList.remove('mobile-controls-visible'); } tapCount = 0; }
        function handleTap(event) { if (gameState !== 'playing') { tapCount = 0; return; } const currentTime = Date.now(); const currentX = event.clientX; const currentY = event.clientY; const timeDiff = currentTime - lastTapTime; let distance = 0; if (tapCount > 0) { const dxTap = currentX - lastTapX; const dyTap = currentY - lastTapY; distance = Math.sqrt(dxTap * dxTap + dyTap * dyTap); } if (timeDiff < TAP_TIME_THRESHOLD && distance < TAP_DISTANCE_THRESHOLD) { tapCount++; } else { tapCount = 1; } lastTapTime = currentTime; lastTapX = currentX; lastTapY = currentY; if (tapCount >= 3) { toggleMobileControls(); } }

        // --- Event Listeners ---
        startGameButton.addEventListener('click', () => { username = usernameInput.value.trim() || 'AAA'; initAudio(); try { initGameVariables(); } catch (initError) { return; } switchState('playing'); showMessage(`Go, ${username}! Use Arrows/WASD.`, 2500); startGameLoop(); });
        restartButton.addEventListener('click', () => { try { initGameVariables(); } catch (initError) { return; } switchState('playing'); showMessage("Let's try again!", 1500); startGameLoop(); });
        showLeaderboardButtonStart.addEventListener('click', displayLeaderboard);
        showLeaderboardButtonGameOver.addEventListener('click', displayLeaderboard);
        closeLeaderboardButton.addEventListener('click', function() {
            console.log("Close leaderboard button clicked, current game state:", gameState);
            
            // Clear any search and selections
            leaderboardSearchInput.value = '';
            clearLeaderboardHighlight();
            
            // Determine which state to return to based on game state
            // If game is over, go back to game over screen
            // Otherwise go to username screen or previous state
            if (isGameOver) {
                console.log("Returning to game over screen");
                switchState('gameover');
                
                // Ensure the game over screen is visible
                setTimeout(() => {
                    const gameOverOverlay = document.getElementById('game-over-overlay');
                    if (gameOverOverlay && !gameOverOverlay.classList.contains('visible')) {
                        console.log("Forcing game over overlay visibility after leaderboard close");
                        gameOverOverlay.classList.add('visible');
                    }
                }, 100);
            } else {
                // Return to username screen or whatever state we were in
                console.log("Returning to username screen");
                switchState('username');
            }
        });
        document.addEventListener('keydown', handleKeyDown);
        howToPlayButton.addEventListener('click', () => { instructionsText.style.display = instructionsText.style.display === 'block' ? 'none' : 'block'; });
        leaderboardSearchInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); handleLeaderboardSearch(); } });
        leaderboardSearchInput.addEventListener('input', () => { if (leaderboardSearchInput.value.trim() === '') { clearLeaderboardHighlight(); } });
        leaderboardSearchButton.addEventListener('click', () => handleLeaderboardSearch());
        upButton.addEventListener('click', () => setDirection(0, -1)); downButton.addEventListener('click', () => setDirection(0, 1)); leftButton.addEventListener('click', () => setDirection(-1, 0)); rightButton.addEventListener('click', () => setDirection(1, 0));
        gameArea.addEventListener('click', handleTap);

        // --- Event Listeners for skin selection ---
        document.getElementById('skin-default').addEventListener('click', () => selectSkin('default'));
        document.getElementById('skin-blue').addEventListener('click', () => selectSkin('blue'));
        document.getElementById('skin-purple').addEventListener('click', () => selectSkin('purple'));
        document.getElementById('skin-orange').addEventListener('click', () => selectSkin('orange'));
        
        function selectSkin(skinName) {
            // Update the selected skin
            currentSkin = skinName;
            
            // Update the UI to show which skin is selected
            document.querySelectorAll('.skin-option').forEach(el => {
                el.classList.remove('selected');
                el.setAttribute('aria-checked', 'false');
            });
            const selectedElement = document.getElementById(`skin-${skinName}`);
            selectedElement.classList.add('selected');
            selectedElement.setAttribute('aria-checked', 'true');
        }

        // --- Initial Setup ---
        // Wait for DOM to be ready before setting initial state
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DEBUG: DOMContentLoaded event fired.");
            
             // Check elements again just before switching state
             if (!usernameOverlay || !gameOverOverlay || !leaderboardOverlay) {
                 console.error("DEBUG: One or more overlay elements are null right before initial switchState!");
             }
            
            switchState('username');
            
            // Show mobile controls automatically on touch devices
            if (isTouchDevice()) {
                mobileControlsVisible = true;
                 mobileControlsContainer.classList.add('mobile-controls-visible');
                
                // Ensure controls are properly positioned
                window.addEventListener('resize', () => {
                    if (mobileControlsVisible) {
                        // Force reflow by toggling class
                        mobileControlsContainer.classList.remove('mobile-controls-visible');
                        setTimeout(() => {
                            mobileControlsContainer.classList.add('mobile-controls-visible');
                        }, 50);
                    }
                });
                
                // Call resize once to ensure proper initial positioning
                window.dispatchEvent(new Event('resize'));
            } else {
                mobileControlsVisible = false;
            }
            
            console.log("DEBUG: Initial setup complete. Current state:", gameState);
        });

        /**
         * Create placeholder icons for iOS
         */
        function createPlaceholderIcons() {
            // Simple data URI for placeholder icons
            const iconDataURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX///+nxBvIAAAAH0lEQVRoge3BAQ0AAADCIPunNsc3YAAAAAAAAAAAADwDTtAAAcfTwbQAAAAASUVORK5CYII=";
            
            // Create link elements for the icons
            const iconSizes = [
                { size: "", filename: "apple-touch-icon.png" },
                { size: "152x152", filename: "apple-touch-icon-152x152.png" },
                { size: "180x180", filename: "apple-touch-icon-180x180.png" },
                { size: "192x192", filename: "icon-192x192.png" },
                { size: "512x512", filename: "icon-512x512.png" }
            ];
            
            // Update href attributes of existing link elements
            iconSizes.forEach(icon => {
                const links = document.querySelectorAll(`link[href="${icon.filename}"]`);
                if (links.length > 0) {
                    links.forEach(link => {
                        link.href = iconDataURI;
                    });
                } else if (icon.size) {
                    // Create new link if needed
                    const link = document.createElement("link");
                    link.rel = "apple-touch-icon";
                    link.sizes = icon.size;
                    link.href = iconDataURI;
                    document.head.appendChild(link);
                }
            });
        }

        // --- Portal Functions ---
        /**
         * Generates a pair of connected portals on the board
         */
        function generatePortalPair() {
            // Clear existing portals
            portals = [];
            
            // Get occupied positions
            const occupied = [
                ...(snake || []), 
                ...(obstacles || []), 
                ...(powerUps || []),
                food ? [food] : []
            ];
            
            // Choose a portal pair color index
            const pairIndex = Math.floor(Math.random() * PORTAL_COLORS.length);
            
            // Generate two portals (entrance and exit)
            for (let i = 0; i < 2; i++) {
                let attempts = 0;
                let portalPos;
                
                // Find valid position
                while (attempts < 50) {
                    portalPos = {
                        x: Math.floor(Math.random() * (tileCount - 2)) + 1, // Avoid edges
                        y: Math.floor(Math.random() * (tileCount - 2)) + 1,
                        pair: pairIndex // Store which color pair this portal belongs to
                    };
                    
                    // Check if position is valid (not occupied by anything including other portals)
                    const collision = occupied.some(p => p.x === portalPos.x && p.y === portalPos.y) ||
                                     portals.some(p => p.x === portalPos.x && p.y === portalPos.y);
                                     
                    if (!collision) {
                        // Valid position found
                        portals.push(portalPos);
                        occupied.push(portalPos); // Mark as occupied for next portal
                        break;
                    }
                    attempts++;
                }
                
                if (attempts >= 50) {
                    console.warn("Could not generate portal");
                    if (i === 0) {
                        // If we couldn't place even the first portal, exit
                        portals = [];
                        return;
                    }
                }
            }
        }
        
        /**
         * Checks if snake head entered a portal and handles teleportation
         */
        function checkPortalTeleport(head) {
            if (portals.length < 2 || portalCooldown) return null;
            
            // Check if head entered a portal
            for (let i = 0; i < portals.length; i++) {
                const portal = portals[i];
                
                if (head.x === portal.x && head.y === portal.y) {
                    // Remove the check that prevents portals from working
                    // if (lastPortalUsed === i) return null;
                    
                    // Find the other portal with the same pair color
                    const otherPortal = portals.find((p, index) => 
                        p.pair === portal.pair && index !== i
                    );
                    
                    if (otherPortal) {
                        // Activate cooldown
                        portalCooldown = true;
                        
                        // Set the last portal used (but no longer check it)
                        lastPortalUsed = i;
                        
                        // Show teleport message
                        showMessage("Teleported!", 1000);
                        
                        // Reset cooldown after delay
                        setTimeout(() => {
                            portalCooldown = false;
                            lastPortalUsed = null; // Reset last portal used
                        }, PORTAL_COOLDOWN);
                        
                        // Return new position (exit portal location)
                        return { x: otherPortal.x, y: otherPortal.y };
                    }
                }
            }
            
            return null;
        }

        // --- Speed Boost Functions ---
        
        /**
         * Update the speed boost button's appearance based on current state
         */
        function updateSpeedBoostButton() {
            const speedBoostButton = document.getElementById('speed-boost-button');
            if (!speedBoostButton) return;
            
            const cooldownOverlay = speedBoostButton.querySelector('.cooldown-overlay');
            
            if (gameState !== 'playing') {
                // Hide button when not playing
                speedBoostButton.classList.remove('visible');
                return;
            }
            
            // Show button during gameplay
            speedBoostButton.classList.add('visible');
            
            // Update button appearance based on cooldown state
            if (speedBoostCooldown) {
                speedBoostButton.classList.add('cooldown');
                
                // Calculate and display cooldown progress
                const cooldownElapsed = Date.now() - (speedBoostTimer - SPEED_BOOST_COOLDOWN);
                const cooldownPercentage = (cooldownElapsed / SPEED_BOOST_COOLDOWN) * 100;
                if (cooldownOverlay) {
                cooldownOverlay.style.height = `${100 - Math.min(cooldownPercentage, 100)}%`;
                }
            } else {
                speedBoostButton.classList.remove('cooldown');
                if (cooldownOverlay) {
                cooldownOverlay.style.height = '0%';
                }
            }
        }
        
        /**
         * Check and update speed boost status (active duration and cooldown)
         */
        function checkSpeedBoostStatus() {
            if (!speedBoostActive && !speedBoostCooldown) return;
            
            const currentTime = Date.now();
            
            if (speedBoostActive && currentTime >= speedBoostTimer) {
                // Speed boost duration ended
                speedBoostActive = false;
                speedBoostCooldown = true;
                
                // Reset game speed to normal
                gameSpeed = normalGameSpeed;
                
                // Set cooldown timer
                speedBoostTimer = currentTime + SPEED_BOOST_COOLDOWN;
                
                showMessage("Speed boost ended", 1000);
            } 
            else if (speedBoostCooldown && currentTime >= speedBoostTimer) {
                // Cooldown period ended
                speedBoostCooldown = false;
                updateSpeedBoostButton();
                
                showMessage("Speed boost ready", 1000);
            }
            
            updateSpeedBoostButton();
        }
        
        /**
         * Activate the speed boost
         */
        function activateSpeedBoost() {
            if (speedBoostActive || speedBoostCooldown || gameState !== 'playing') {
                return; // Already active or on cooldown
            }
            
            // Activate speed boost
            speedBoostActive = true;
            
            // Remember normal speed to restore later
            normalGameSpeed = gameSpeed;
            
            // Set boosted speed (60% faster)
            gameSpeed = Math.max(30, Math.floor(gameSpeed * 0.4));
            
            // Set duration timer
            speedBoostTimer = Date.now() + SPEED_BOOST_DURATION;
            
            // Show message
            showMessage("Speed boost activated!", 1000);
            
            updateSpeedBoostButton();
        }
        
        // Add event listener for speed boost button
        document.getElementById('speed-boost-button').addEventListener('click', activateSpeedBoost);

        // Add keyboard accessibility for skin selection
        document.querySelectorAll('.skin-option').forEach(skinOption => {
            skinOption.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    const skinId = skinOption.id.replace('skin-', '');
                    selectSkin(skinId);
                }
            });
        });

        // --- Achievement System ---
        const ACHIEVEMENTS = [
            {
                id: 'first_apple',
                name: 'First Bite',
                description: 'Eat your first apple',
                icon: '🍎',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'apple_collector',
                name: 'Apple Collector',
                description: 'Eat 25 apples',
                icon: '🍏',
                requirement: 25,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'golden_hunter',
                name: 'Golden Hunter',
                description: 'Collect 5 golden apples',
                icon: '✨',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'portal_master',
                name: 'Portal Master',
                description: 'Use portals 10 times',
                icon: '🌀',
                requirement: 10,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'speed_demon',
                name: 'Speed Demon',
                description: 'Use speed boost 3 times',
                icon: '⚡',
                requirement: 3,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'long_snake',
                name: 'Long Snake',
                description: 'Grow to length 20',
                icon: '🐍',
                requirement: 20,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'mini_game_master',
                name: 'Mini-Game Master',
                description: 'Score 15+ points in a mini-game',
                icon: '🎮',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'apple_feast',
                name: 'Apple Feast',
                description: 'Eat 50 apples',
                icon: '🍎',
                requirement: 50,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'apple_orchard',
                name: 'Apple Orchard',
                description: 'Eat 100 apples',
                icon: '🏆',
                requirement: 100,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'golden_treasure',
                name: 'Golden Treasure',
                description: 'Collect 10 golden apples',
                icon: '🌟',
                requirement: 10,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'golden_hoard',
                name: 'Golden Hoard',
                description: 'Collect 20 golden apples',
                icon: '💰',
                requirement: 20,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'portal_jumper',
                name: 'Portal Jumper',
                description: 'Use portals 25 times',
                icon: '🌌',
                requirement: 25,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'portal_wizard',
                name: 'Portal Wizard',
                description: 'Use portals 50 times',
                icon: '🔮',
                requirement: 50,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'shield_bearer',
                name: 'Shield Bearer',
                description: 'Use shield power-up 5 times',
                icon: '🛡️',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'ghost_rider',
                name: 'Ghost Rider',
                description: 'Use ghost power-up 5 times',
                icon: '👻',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'magnet_master',
                name: 'Magnet Master',
                description: 'Use magnet power-up 5 times',
                icon: '🧲',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'shrink_specialist',
                name: 'Shrink Specialist',
                description: 'Use shrink power-up 5 times',
                icon: '📏',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'speed_master',
                name: 'Speed Master',
                description: 'Use speed boost 10 times',
                icon: '🚀',
                requirement: 10,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'slow_master',
                name: 'Slow Master',
                description: 'Use slow power-up 5 times',
                icon: '🐢',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'anaconda',
                name: 'Anaconda',
                description: 'Grow to length 40',
                icon: '🐉',
                requirement: 40,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'python',
                name: 'Python',
                description: 'Grow to length 60',
                icon: '🔥',
                requirement: 60,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'mini_game_champion',
                name: 'Mini-Game Champion',
                description: 'Score 30+ points in a mini-game',
                icon: '🏅',
                requirement: 30,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'survivor',
                name: 'Survivor',
                description: 'Play for 2 minutes without dying',
                icon: '⏱️',
                requirement: 120,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'marathon_runner',
                name: 'Marathon Runner',
                description: 'Play for 5 minutes without dying',
                icon: '⏳',
                requirement: 300,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'endurance_champion',
                name: 'Endurance Champion',
                description: 'Play for 10 minutes without dying',
                icon: '🏃',
                requirement: 600,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'wall_crawler',
                name: 'Wall Crawler',
                description: 'Move along the edge of the map for 15 seconds',
                icon: '🧱',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'trickster',
                name: 'Trickster',
                description: 'Narrowly avoid hitting your tail 5 times',
                icon: '🎭',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'apex_predator',
                name: 'Apex Predator',
                description: 'Reach a score of 200',
                icon: '👑',
                requirement: 200,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'legendary_serpent',
                name: 'Legendary Serpent',
                description: 'Reach a score of 500',
                icon: '🏆',
                requirement: 500,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'risk_taker',
                name: 'Risk Taker',
                description: 'Eat an apple while having 3+ powerups active',
                icon: '🎲',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'powerup_hoarder',
                name: 'Powerup Hoarder',
                description: 'Have 5 powerups active simultaneously',
                icon: '⭐',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'shield_master',
                name: 'Shield Master',
                description: 'Use shield power-up 15 times',
                icon: '🛡️',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'ghost_master',
                name: 'Ghost Master',
                description: 'Use ghost power-up 15 times',
                icon: '👻',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'magnet_wizard',
                name: 'Magnet Wizard',
                description: 'Use magnet power-up 15 times',
                icon: '🧲',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'shrink_master',
                name: 'Shrink Master',
                description: 'Use shrink power-up 15 times',
                icon: '📏',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'speed_wizard',
                name: 'Speed Wizard',
                description: 'Use speed boost 20 times',
                icon: '⚡',
                requirement: 20,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'slow_wizard',
                name: 'Slow Wizard',
                description: 'Use slow power-up 15 times',
                icon: '🐢',
                requirement: 15,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'sharp_turn',
                name: 'Sharp Turn',
                description: 'Make 50 quick direction changes',
                icon: '↩️',
                requirement: 50,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'close_call',
                name: 'Close Call',
                description: 'Survive 10 near collisions with your tail',
                icon: '😅',
                requirement: 10,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'golden_streak',
                name: 'Golden Streak',
                description: 'Collect 3 golden apples in a row',
                icon: '🔆',
                requirement: 3,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'night_crawler',
                name: 'Night Crawler',
                description: 'Play the game between 10 PM and 5 AM',
                icon: '🌙',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'early_bird',
                name: 'Early Bird',
                description: 'Play the game between 5 AM and 9 AM',
                icon: '🌅',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'weekend_warrior',
                name: 'Weekend Warrior',
                description: 'Play on both Saturday and Sunday',
                icon: '📅',
                requirement: 2,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'consistent_player',
                name: 'Consistent Player',
                description: 'Play for 5 consecutive days',
                icon: '📊',
                requirement: 5,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'leaderboard_novice',
                name: 'Leaderboard Novice',
                description: 'Get on the leaderboard for the first time',
                icon: '📋',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            },
            {
                id: 'leaderboard_champion',
                name: 'Leaderboard Champion',
                description: 'Reach the top 3 on the leaderboard',
                icon: '🥇',
                requirement: 1,
                progress: 0,
                reward: null,
                unlocked: false
            }
        ];

        // Track achievements and save to localStorage
        let playerAchievements = JSON.parse(localStorage.getItem('snake_achievements')) || [...ACHIEVEMENTS];

        function updateAchievement(id, increment = 1) {
            const achievement = playerAchievements.find(a => a.id === id);
            if (!achievement || achievement.unlocked) return;
            
            achievement.progress += increment;
            
            // Check if achievement is completed
            if (achievement.progress >= achievement.requirement) {
                achievement.unlocked = true;
                achievement.progress = achievement.requirement;
                showAchievementPopup(achievement);
            }
            
            // Save to localStorage
            localStorage.setItem('snake_achievements', JSON.stringify(playerAchievements));
            
            // Update UI if achievements overlay is visible
            if (document.getElementById('achievements-overlay').classList.contains('visible')) {
                populateAchievements();
            }
        }

        function populateAchievements() {
            try {
                const container = document.getElementById('achievements-list');
                if (!container) {
                    console.error("Achievements list container not found!");
                    return;
                }
                
                // Clear container safely
                container.innerHTML = '';
                
                playerAchievements.forEach(achievement => {
                    try {
                        const elem = document.createElement('div');
                        elem.className = `achievement ${achievement.unlocked ? '' : 'locked'}`;
                        
                        const progressPercent = Math.min(100, (achievement.progress / achievement.requirement) * 100);
                        
                        elem.innerHTML = `
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div class="achievement-name">${achievement.name}</div>
                            <div class="achievement-desc">${achievement.description}</div>
                            <div class="achievement-progress">
                                <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                            </div>
                        `;
                        
                        safeAppendChild(container, elem);
                    } catch (achievementError) {
                        console.error("Error creating achievement element:", achievementError);
                    }
                });
            } catch (e) {
                console.error("Error in populateAchievements:", e);
            }
        }

        function showAchievementPopup(achievement) {
            try {
                const popup = document.getElementById('achievement-popup');
                if (!popup) return;
                
                const title = popup.querySelector('.achievement-title');
                const description = popup.querySelector('.achievement-description');
                
                if (title) title.textContent = `Achievement Unlocked: ${achievement.name}`;
                if (description) description.textContent = achievement.description;
                
                popup.classList.add('show');
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    try {
                        popup.classList.remove('show');
                    } catch (e) {
                        console.error("Error hiding achievement popup:", e);
                    }
                }, 3000);
            } catch (e) {
                console.error("Error showing achievement popup:", e);
            }
        }

        // --- Mini-Games ---
        let miniGameActive = false;
        let miniGameScore = 0;
        let miniGameTimer = 0;
        let miniGameInterval = null;

        function startMiniGame(isFromGameOver = false) {
            try {
                console.log(`Starting mini-game (isFromGameOver: ${isFromGameOver})`);
                
                // Store the isFromGameOver flag in a global variable to ensure it's available later
                window.miniGameIsFromGameOver = isFromGameOver;
                
                const miniGameContainer = document.getElementById('mini-game-container');
                if (!miniGameContainer) {
                    console.error("Mini-game container not found!");
                    if (isFromGameOver) {
                        switchState('gameover');
                    }
                    return;
                }
                
                const miniGameArea = document.getElementById('mini-game-area');
                if (!miniGameArea) {
                    console.error("Mini-game area not found!");
                    if (isFromGameOver) {
                        switchState('gameover');
                    }
                    return;
                }
                
                const miniGameTitle = miniGameContainer.querySelector('.mini-game-title');
                const miniGameInstructions = miniGameContainer.querySelector('.mini-game-instructions');
                
                // Set different texts based on context
                if (isFromGameOver) {
                    if (miniGameTitle) miniGameTitle.textContent = 'Bonus Round!';
                    if (miniGameInstructions) miniGameInstructions.textContent = 'Tap/click as many apples as you can in 10 seconds for bonus points!';
                } else {
                    if (miniGameTitle) miniGameTitle.textContent = 'Apple Chase Challenge!';
                    if (miniGameInstructions) miniGameInstructions.textContent = 'Tap/click as many apples as you can in 10 seconds!';
                }
                
                // Cancel any ongoing animation frames
                if (animationFrameId) {
                    try {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    } catch (e) {
                        console.error("Error canceling animation frame:", e);
                    }
                }
                
                // Clear any existing interval
                if (miniGameInterval) {
                    clearInterval(miniGameInterval);
                    miniGameInterval = null;
                }
                
                miniGameContainer.classList.add('active');
                miniGameActive = true;
                miniGameScore = 0;
                miniGameTimer = 10; // 10 seconds
                
                // Clear previous game
                miniGameArea.innerHTML = `
                    <div id="mini-game-timer" aria-live="polite">10</div>
                    <div id="mini-game-score" aria-live="polite">Score: 0</div>
                `;
                
                // Create apples immediately
                try {
                    console.log("Creating apples in startMiniGame");
                    createApples();
                    
                    // Verify apples were created
                    const appleCount = miniGameArea.querySelectorAll('.mini-game-apple').length;
                    console.log(`Created ${appleCount} apples`);
                    
                    // If no apples were created, try again
                    if (appleCount === 0) {
                        console.log("No apples created, trying again");
                        setTimeout(() => {
                            createApples();
                        }, 100);
                    }
                } catch (e) {
                    console.error("Error creating apples:", e);
                }
                
                // Don't start timer automatically - let user click Start button
                // This allows them to see the instructions before starting
            } catch (e) {
                console.error("Error starting mini-game:", e);
                if (isFromGameOver) {
                    switchState('gameover');
                }
            }
        }

        function createApples() {
            try {
                const miniGameArea = document.getElementById('mini-game-area');
                if (!miniGameArea) {
                    console.error("Mini-game area element not found!");
                    return;
                }
                
                const appleCount = isTouchDevice() ? 4 : 6; // Fewer apples on mobile for better UX
                
                for (let i = 0; i < appleCount; i++) {
                    createApple();
                }
                
                // Add touch event listeners for mobile
                // Remove existing listeners first to avoid duplicates
                miniGameArea.removeEventListener('touchstart', handleMiniGameTouch);
                miniGameArea.removeEventListener('touchmove', handleMiniGameTouch);
                
                // Add both touchstart and touchmove for better responsiveness
                if (isTouchDevice()) {
                    miniGameArea.addEventListener('touchstart', handleMiniGameTouch, { passive: false });
                    miniGameArea.addEventListener('touchmove', handleMiniGameTouch, { passive: false });
                    
                    console.log("Touch event listeners added for mini-game");
                    
                    // Make sure touch visual is more prominent
                    document.querySelectorAll('.mini-game-apple').forEach(apple => {
                        apple.style.width = '40px';  // Bigger targets for touch
                        apple.style.height = '40px';
                    });
                }
            } catch (e) {
                console.error("Error in createApples:", e);
            }
        }

        function createApple() {
            try {
                const miniGameArea = document.getElementById('mini-game-area');
                if (!miniGameArea) {
                    console.error("Mini-game area element not found!");
                    return null;
                }
                
                // Create the apple element
                const apple = document.createElement('div');
                apple.className = 'mini-game-apple';
                
                // Make sure apple is visible
                apple.style.width = '30px'; // Slightly larger
                apple.style.height = '30px';
                apple.style.position = 'absolute';
                apple.style.borderRadius = '50%';
                apple.style.backgroundColor = foodColor;
                apple.style.zIndex = '100'; // Ensure it's on top
                apple.style.boxShadow = '0 0 5px rgba(0,0,0,0.5)'; // Add shadow for visibility
                apple.style.cursor = 'pointer'; // Make clickable by default
                apple.style.transition = 'transform 0.1s';
                apple.style.opacity = '1'; // Fully visible by default
                apple.dataset.clickable = 'true'; // Mark as clickable by default
                
                // Safely get dimensions
                const areaWidth = miniGameArea.clientWidth || 300;
                const areaHeight = miniGameArea.clientHeight || 200;
                
                // Position the apple with some padding from edges
                const padding = 40;
                apple.style.left = `${padding + Math.random() * (areaWidth - 30 - padding*2)}px`;
                apple.style.top = `${padding + Math.random() * (areaHeight - 30 - padding*2)}px`;
                
                // Add hover effect
                apple.addEventListener('mouseover', () => {
                    if (apple.dataset.clickable === 'true') {
                        apple.style.transform = 'scale(1.1)';
                    }
                });
                
                apple.addEventListener('mouseout', () => {
                    apple.style.transform = 'scale(1)';
                });
                
                // Add click handler
                apple.addEventListener('click', (e) => {
                    // Prevent event bubbling
                    e.stopPropagation();
                    
                    // Increase score
                    miniGameScore += 1;
                    const scoreElement = document.getElementById('mini-game-score');
                    if (scoreElement) {
                        scoreElement.textContent = `Score: ${miniGameScore}`;
                    }
                    
                    // Remove apple and create a new one
                    if (apple.parentNode) {
                        apple.parentNode.removeChild(apple);
                    } else {
                        console.warn("Apple has no parent node when clicked");
                    }
                    
                    // Create a new apple
                    try {
                        createApple();
                    } catch (e) {
                        console.error("Error creating new apple:", e);
                    }
                    
                    // Add visual effect
                    try {
                        const x = parseInt(apple.style.left) || 0;
                        const y = parseInt(apple.style.top) || 0;
                        createParticles(3, '🍎', {
                            x: e.clientX,
                            y: e.clientY
                        }, miniGameArea);
                        
                        // Play sound if available
                        try {
                            if (audioReady && eatSound) {
                                eatSound.triggerAttackRelease('C6', '32n', Tone.now());
                            }
                        } catch (soundError) {
                            console.error("Error playing apple sound:", soundError);
                        }
                    } catch (particleError) {
                        console.error("Error creating particles:", particleError);
                    }
                });
                
                // Add to mini-game area
                safeAppendChild(miniGameArea, apple);
                
                return apple;
            } catch (e) {
                console.error("Error in createApple:", e);
                return null;
            }
        }

        function endMiniGame(isFromGameOver = false) {
            try {
                console.log("Ending mini-game, cleaning up resources...");
                
                // Use the stored global variable if available, otherwise use the parameter
                // This ensures consistency between start and end of mini-game
                isFromGameOver = window.miniGameIsFromGameOver || isFromGameOver;
                console.log(`endMiniGame called with isFromGameOver: ${isFromGameOver}`);
                
                if (miniGameInterval) {
                    clearInterval(miniGameInterval);
                    miniGameInterval = null;
                }
                
                const miniGameContainer = document.getElementById('mini-game-container');
                if (miniGameContainer) {
                    miniGameContainer.classList.remove('active');
                }
                
                miniGameActive = false;
                
                // Award points based on mini-game score
                const pointsEarned = miniGameScore * 2;
                score += pointsEarned;
                updateScoreDisplay();
                
                // Update achievement for mini-games
                try {
                    updateAchievement('apple_collector', miniGameScore);
                    updateAchievement('mini_game_master', miniGameScore);
                } catch (e) {
                    console.error("Error updating achievements:", e);
                }
                
                // Show celebration if player achieved a high mini-game score
                if (miniGameScore >= 15) {
                    try {
                        createParticles(10, '🎮', {
                            x: window.innerWidth / 2,
                            y: window.innerHeight / 2
                        });
                        playAchievementSound();
                    } catch (e) {
                        console.error("Error creating celebration:", e);
                    }
                }
                
                showMessage(`Mini-game complete! Earned ${pointsEarned} points!`, 2000);
                
                // Save the final score to API again after mini-game points are added
                if (username && score > 0) {
                    try {
                        // Use the stored finalTimeScore from window or from the regular variable
                        const currentTimeScore = window.finalSnakeTimeScore || finalTimeScore;
                        
                        console.log(`Saving final score to API after mini-game: ${username}, ${score}, ${currentTimeScore}`);
                        
                        // Verify time score is a valid number
                        if (isNaN(currentTimeScore) || typeof currentTimeScore !== 'number') {
                            console.warn("Invalid time score detected in endMiniGame, using current game time");
                            finalTimeScore = Math.floor((Date.now() - gameStartTime) / 1000);
                        } else {
                            finalTimeScore = currentTimeScore;
                        }
                        
                        console.log(`Validated time score: ${finalTimeScore}`);
                        
                        saveScoreToAPI(username, score, finalTimeScore)
                            .then(() => {
                                console.log("Score saved successfully after mini-game");
                            })
                            .catch(err => {
                                console.error("Error saving score after mini-game:", err);
                            });
                    } catch (e) {
                        console.error("Error saving score after mini-game:", e);
                    }
                }
                
                // Make sure we always show the game over screen after a short delay
                // This is important to prevent the game from getting stuck
                setTimeout(() => {
                    console.log(`Mini-game ended, isFromGameOver: ${isFromGameOver}`);
                    
                    if (isFromGameOver) {
                        // Now show the game over screen
                        console.log("Switching to gameover state");
                        
                        // Force game over state
                        isGameOver = true;
                        gameState = 'gameover';
                        
                        // Update the final score display to include mini-game points
                        if (finalScoreElement) {
                            finalScoreElement.textContent = `Score: ${score} | Time: ${formatTime(finalTimeScore)}`;
                        }
                        
                        // Clear any stored flags
                        window.miniGameIsFromGameOver = undefined;
                        
                        // Hide all overlays first to ensure a clean state
                        document.querySelectorAll('.overlay').forEach(overlay => overlay.classList.remove('visible'));
                        
                        // Hide the mini-game container explicitly
                        const miniGameContainer = document.getElementById('mini-game-container');
                        if (miniGameContainer) {
                            miniGameContainer.classList.remove('active');
                        }
                        
                        // Directly call switchState to ensure the overlay is visible
                        switchState('gameover');
                        
                        // Double-check the overlay is visible as a fallback
                        setTimeout(() => {
                            const gameOverOverlay = document.getElementById('game-over-overlay');
                            if (gameOverOverlay && !gameOverOverlay.classList.contains('visible')) {
                                console.log("Forcing game over overlay visibility");
                                gameOverOverlay.classList.add('visible');
                            }
                            
                            // Log the current state to help with debugging
                            console.log("Game state after mini-game end: ", {
                                gameState: gameState,
                                isGameOver: isGameOver,
                                isGameOverOverlayVisible: gameOverOverlay?.classList.contains('visible'),
                                miniGameActive: miniGameActive
                            });
                            
                            // Third safety check - direct DOM manipulation if needed
                            if (gameState === 'gameover' && (!gameOverOverlay || !gameOverOverlay.classList.contains('visible'))) {
                                console.warn("Game over screen still not visible! Using direct method.");
                                // Try direct DOM manipulation
                                document.querySelectorAll('.overlay').forEach(overlay => overlay.classList.remove('visible'));
                                const gameOver = document.getElementById('game-over-overlay');
                                if (gameOver) {
                                    gameOver.classList.add('visible');
                                    // Update player rank info if possible
                                    loadLeaderboard().then(() => {
                                        displayPlayerRank();
                                    }).catch(e => console.error("Error loading leaderboard:", e));
                                }
                            }
                        }, 100);
                        
                        // Update high score if needed
                        try {
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('snakeHighScore', score);
                                showMessage("New High Score! 🎉", 3000);
                            }
                        } catch (e) {
                            console.error("Error updating high score:", e);
                        }
                    } else if (gameState === 'playing') {
                        // Resume main game if was playing
                        startGameLoop();
                    } else {
                        // Fallback in case we're in an unknown state
                        console.warn("Unknown game state when ending mini-game:", gameState);
                        switchState('gameover');
                    }
                }, 1000); // Longer delay to ensure messages are visible and transition is smoother
            } catch (e) {
                console.error("Error in endMiniGame:", e);
                // Ensure we at least transition to a valid state
                gameState = 'gameover';
                isGameOver = true;
                
                // Force switch to game over as a fallback
                try {
                    switchState('gameover');
                    
                    // Direct approach if switchState fails
                    document.getElementById('game-over-overlay').classList.add('visible');
                } catch (finalError) {
                    console.error("Critical error showing game over screen:", finalError);
                }
            }
        }

        // --- Visual Effects ---
        function createParticles(count, emoji, position = null, container = document.body) {
            // Default position to center of screen if not provided
            if (!position) {
                position = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
            }
            
            // Ensure position has x and y properties
            if (typeof position !== 'object' || position === null || typeof position.x !== 'number' || typeof position.y !== 'number') {
                console.warn("Invalid position for particles, using default position");
                position = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
            }
            
            for (let i = 0; i < count; i++) {
                try {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.textContent = emoji || '✨'; // Default emoji if none provided
                    
                    const x = position.x + (Math.random() * 40 - 20);
                    const y = position.y + (Math.random() * 40 - 20);
                    
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    
                    // Random direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    // Store velocity
                    particle.dataset.vx = vx;
                    particle.dataset.vy = vy;
                    
                    // Add to container using our safe append function
                    if (container && container.appendChild) {
                        safeAppendChild(container, particle);
                    } else {
                        safeAppendChild(document.body, particle);
                    }
                    
                    // Animate and remove after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 1000);
                    
                    // Move particles
                    let animTime = 0;
                    const moveParticle = (timestamp) => {
                        if (!particle.parentNode) return;
                        
                        if (!animTime) animTime = timestamp;
                        const elapsed = timestamp - animTime;
                        animTime = timestamp;
                        
                        const currentX = parseFloat(particle.style.left);
                        const currentY = parseFloat(particle.style.top);
                        const vx = parseFloat(particle.dataset.vx);
                        const vy = parseFloat(particle.dataset.vy) + 0.1; // Add gravity
                        
                        particle.style.left = `${currentX + vx}px`;
                        particle.style.top = `${currentY + vy}px`;
                        particle.dataset.vy = vy;
                        
                        // Fade out
                        particle.style.opacity = parseFloat(particle.style.opacity || 1) - 0.02;
                        
                        if (parseFloat(particle.style.opacity) > 0) {
                            requestAnimationFrame(moveParticle);
                        }
                    };
                    
                    requestAnimationFrame(moveParticle);
                } catch (e) {
                    console.error("Error creating particle:", e);
                }
            }
        }

        function playAchievementSound() {
            if (audioReady && eatSound && Tone.context.state === 'running') {
                try {
                    // Play a C major chord for achievement
                    eatSound.triggerAttackRelease('C4', '8n', Tone.now());
                    setTimeout(() => {
                        eatSound.triggerAttackRelease('E4', '8n', Tone.now());
                    }, 100);
                    setTimeout(() => {
                        eatSound.triggerAttackRelease('G4', '8n', Tone.now());
                    }, 200);
                } catch (e) {
                    console.error("Error playing achievement sound:", e);
                }
            }
        }

        // --- Modified Game Functions to Support New Features ---

        // Update checkGameOver to handle ghost mode
        function checkGameOver() { 
            const head = snake[0]; 
            if (!head) return true; 
            
            // If shield power-up is active or ghost mode, no collision death
            if (activePowerUp && (activePowerUp.type === 'shield' || activePowerUp.type === 'ghost')) {
                // Still need to check if snake is on the board
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    // Just wrap around the board for ghost mode
                    if (activePowerUp.type === 'ghost') {
                        if (head.x < 0) head.x = tileCount - 1;
                        if (head.x >= tileCount) head.x = 0;
                        if (head.y < 0) head.y = tileCount - 1;
                        if (head.y >= tileCount) head.y = 0;
                    } else {
                        // For shield, just stop at edges
                        if (head.x < 0) head.x = 0;
                        if (head.x >= tileCount) head.x = tileCount - 1;
                        if (head.y < 0) head.y = 0;
                        if (head.y >= tileCount) head.y = tileCount - 1;
                    }
                    return false;
                }
                return false; // No death with shield or ghost
            }
            
            // Standard collision checks
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) return true; 
            
            for (let i = 1; i < snake.length; i++) { 
                if (head.x === snake[i].x && head.y === snake[i].y) return true; 
            } 
            
            if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) return true; 
            
            return false; 
        }

        // Update moveSnake to handle magnet power-up
        function moveSnake() { 
            if (dx === 0 && dy === 0) return; 
            
            const head = { x: snake[0].x + dx, y: snake[0].y + dy }; 
            
            // Check for portal teleportation
            const portalEntered = checkPortalTeleport(head);
            if (portalEntered) {
                // Update achievement for portal usage
                updateAchievement('portal_master', 1);
                
                // If teleported, update the head position
                head.x = portalEntered.x;
                head.y = portalEntered.y;
            }
            
            snake.unshift(head); 
            
            // Handle magnet power-up
            if (activePowerUp && activePowerUp.type === 'magnet') {
                handleMagnetPowerUp(head);
            }
            
            if (head.x === food.x && head.y === food.y) { 
                handleFoodCollision(head);
            } else { 
                snake.pop(); 
            } 
            
            // Check for power-up collection
            checkPowerUpCollected();
            // Check if active power-up has expired
            checkPowerUpExpiry();
            // Check speed boost status
            checkSpeedBoostStatus();
        }

        // Extract magnet power-up logic to a separate function
        function handleMagnetPowerUp(head) {
            // Calculate distance to food
            const dx = food.x - head.x;
            const dy = food.y - head.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If food is within range (5 grid cells)
            if (distance < 5) {
                // Move food closer to snake head
                const moveX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
                const moveY = dy > 0 ? 1 : dy < 0 ? -1 : 0;
                
                // Check if moving food would place it on an obstacle
                const newFoodX = food.x - moveX;
                const newFoodY = food.y - moveY;
                
                const isCollision = obstacles.some(o => o.x === newFoodX && o.y === newFoodY) || 
                                   snake.some(s => s.x === newFoodX && s.y === newFoodY);
                
                if (!isCollision) {
                    food.x = newFoodX;
                    food.y = newFoodY;
                }
            }
        }

        // Extract food collision logic to a separate function
        function handleFoodCollision(head) {
            // Different points for different food types
            let pointValue = 10; // Default
            
            switch(food.type) {
                case 'golden':
                    pointValue = 20;
                    updateAchievement('golden_hunter', 1);
                    break;
                case 'small':
                    pointValue = 5;
                    break;
                default:
                    updateAchievement('first_apple', 1);
                    updateAchievement('apple_collector', 1);
                    break;
            }
            
            score += pointValue; 
            playEatSound(); 
            updateScoreDisplay(); 
            generateFood(); 
            
            // Check snake length achievement
            if (snake.length >= 20) {
                updateAchievement('long_snake', 1);
            }
            
            if (gameSpeed > 60 && !activePowerUp && !speedBoostActive) gameSpeed -= 2; 
            normalGameSpeed = gameSpeed; // Update normal speed
            
            // Create particles for visual effect
            createParticles(3, '✨', {
                x: head.x * gridSize + gridSize/2,
                y: head.y * gridSize + gridSize/2
            });
        }

        // Update activateSpeedBoost to track achievements
        function activateSpeedBoost() {
            if (speedBoostActive || speedBoostCooldown || gameState !== 'playing') {
                return; // Already active or on cooldown
            }
            
            // Update achievement
            updateAchievement('speed_demon', 1);
            
            // Activate speed boost
            speedBoostActive = true;
            
            // Remember normal speed to restore later
            normalGameSpeed = gameSpeed;
            
            // Set boosted speed (60% faster)
            gameSpeed = Math.max(30, Math.floor(gameSpeed * 0.4));
            
            // Set duration timer
            speedBoostTimer = Date.now() + SPEED_BOOST_DURATION;
            
            // Show message
            showMessage("Speed boost activated!", 1000);
            
            // Create particles for visual effect
            createParticles(5, '⚡', {
                x: snake[0].x * gridSize + gridSize/2,
                y: snake[0].y * gridSize + gridSize/2
            });
            
            // Add shake effect to game area
            gameArea.classList.add('shake');
            setTimeout(() => gameArea.classList.remove('shake'), 500);
            
            updateSpeedBoostButton();
        }

        // Update UI with achievements button
        function updateUI() {
            // Create achievement button if not exists
            if (!document.getElementById('show-achievements-button')) {
                const ui = document.getElementById('ui-container');
                const achievementButton = document.createElement('button');
                achievementButton.id = 'show-achievements-button';
                achievementButton.innerHTML = '🏆';
                achievementButton.style.marginLeft = '10px';
                achievementButton.style.background = 'none';
                achievementButton.style.border = '1px solid var(--primary-color)';
                achievementButton.style.color = 'var(--primary-color)';
                achievementButton.style.borderRadius = '50%';
                achievementButton.style.width = '30px';
                achievementButton.style.height = '30px';
                achievementButton.style.display = 'flex';
                achievementButton.style.alignItems = 'center';
                achievementButton.style.justifyContent = 'center';
                achievementButton.style.cursor = 'pointer';
                achievementButton.title = 'Achievements';
                
                achievementButton.addEventListener('click', () => {
                    populateAchievements();
                    document.getElementById('achievements-overlay').classList.add('visible');
                });
                
                ui.insertBefore(achievementButton, document.getElementById('speed-boost-button'));
            }
        }

        // Add event listeners for mini-game and achievements
        document.getElementById('mini-game-start').addEventListener('click', startMiniGame);
        document.getElementById('mini-game-skip').addEventListener('click', function() {
            try {
                // Determine if we're coming from a game over state
                const isFromGameOver = gameState !== 'playing';
                console.log(`Skipping mini-game (isFromGameOver: ${isFromGameOver})`);
                
                // Use the endMiniGame function to properly handle this
                endMiniGame(isFromGameOver);
            } catch (e) {
                console.error("Error skipping mini-game:", e);
                if (gameState !== 'playing') {
                    switchState('gameover');
                }
            }
        });

        document.getElementById('close-achievements-button').addEventListener('click', () => {
            document.getElementById('achievements-overlay').classList.remove('visible');
        });

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            console.log("DOM Content Loaded - Initializing game");
            
            // Check if API is reachable
            const isApiReachable = await checkApiEndpoint();
            console.log(`API reachable: ${isApiReachable}`);
            
            // Set up audio
            try {
                initAudio();
            } catch (e) {
                console.warn("Could not initialize audio:", e);
            }
            
            // Initialize achievements and UI
            updateUI();
        });

        // Update the game over handling to show mini-game as a bonus
        function handleGameOver() {
            if (isGameOver) return; // Prevent multiple calls
            
            console.log("handleGameOver called - game is ending");
            
            isGameOver = true;
            dx = 0;
            dy = 0;
            
            try {
                // CRITICAL TIME SCORE CALCULATION
                // First ensure gameStartTime was set
                if (!gameStartTime || isNaN(gameStartTime)) {
                    console.warn("gameStartTime was not set properly!");
                    gameStartTime = Date.now() - 60000; // Assume at least 1 minute of play
                }
                
                // Calculate final time score - try all possible sources in order of reliability
                let calculatedTimeScore = Math.floor((Date.now() - gameStartTime) / 1000);
                
                // First try window.lastKnownTimeScore (continuously updated by timer)
                if (window.lastKnownTimeScore && typeof window.lastKnownTimeScore === 'number') {
                    finalTimeScore = Math.max(1, window.lastKnownTimeScore);
                    console.log(`Using lastKnownTimeScore: ${finalTimeScore}`);
                } 
                // Then try timerElement's data attribute (if available)
                else if (timerElement && timerElement.getAttribute('data-seconds')) {
                    const dataSeconds = parseInt(timerElement.getAttribute('data-seconds'), 10);
                    if (!isNaN(dataSeconds) && dataSeconds > 0) {
                        finalTimeScore = dataSeconds;
                        console.log(`Using timer data attribute: ${finalTimeScore}`);
                    } else {
                        finalTimeScore = Math.max(1, calculatedTimeScore);
                        console.log(`Using calculated time: ${finalTimeScore}`);
                    }
                } 
                // Finally fall back to direct calculation
                else {
                    finalTimeScore = Math.max(1, calculatedTimeScore);
                    console.log(`Using calculated time: ${finalTimeScore}`);
                }
                
                // Ensure finalTimeScore is at least 1 second and is an integer
                finalTimeScore = Math.max(1, Math.floor(finalTimeScore));
                
                // CRUCIAL: Save to multiple locations for redundancy
                window.finalSnakeTimeScore = finalTimeScore;
                window.lastKnownTimeScore = finalTimeScore;
                
                console.log(`Game over - Final time: ${finalTimeScore} seconds (type: ${typeof finalTimeScore})`);
                
                // Play game over sound
                playGameOverSound();
                
                // CRITICAL: Save score to API if username exists
                if (username) {
                    console.log(`Calling saveScoreToAPI with name=${username}, score=${score}, time=${finalTimeScore}`);
                    saveScoreToAPI(username, score, finalTimeScore);
                }
                
                // Update high score if needed
                if (score > highScore) {
                    highScore = score; 
                    localStorage.setItem('snakeHighScore', score);
                    showMessage("New High Score! 🎉", 3000);
                }
                
                // Show game over screen with final score and time
                if (finalScoreElement) {
                    finalScoreElement.textContent = `Score: ${score} | Time: ${formatTime(finalTimeScore)}`;
                }
                
                // Check if we should show mini-game
                const shouldShowMiniGame = Math.random() < 0.75; // Increased chance to 75% for testing
                
                console.log("Game Over - preparing to show game over screen");
                console.log(`Should show mini-game: ${shouldShowMiniGame}`);
                
                // Make sure we're in a consistent state
                gameState = 'gameover';
                
                if (shouldShowMiniGame) {
                    // First, explicitly hide all overlays to avoid state conflicts
                    document.querySelectorAll('.overlay').forEach(overlay => {
                        overlay.classList.remove('visible');
                    });
                    
                    console.log("Starting mini-game from game over");
                    
                    // Clear any previous mini-game state
                    miniGameActive = false;
                    if (miniGameInterval) {
                        clearInterval(miniGameInterval);
                        miniGameInterval = null;
                    }
                    
                    // Briefly show a message to prepare the user
                    showMessage("Bonus mini-game coming up!", 1500);
                    
                    // Start the mini-game with a delay to ensure clean state transition
                    setTimeout(() => {
                        startMiniGame(true);
                    }, 500);
                } else {
                    console.log("No mini-game, showing game over screen directly");
                    switchState('gameover');
                    
                    // Update leaderboard info if possible
                    try {
                        loadLeaderboard().then(() => {
                            displayPlayerRank();
                        });
                    } catch (e) {
                        console.error("Error loading leaderboard in game over:", e);
                    }
                }
            } catch (e) {
                console.error("Error in game over flow:", e);
                // Make sure we always show the game over screen as fallback
                switchState('gameover');
            }
        }

        // Helper function to safely show game over screen
        function safelyShowGameOver() {
            try {
                console.log("Safely showing game over screen");
                
                // Ensure we're in the game over state
                switchState('gameover');
                
                // Also make sure the overlay is visible, as a fallback
                const gameOverOverlay = document.getElementById('game-over-overlay');
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('visible');
                    
                    // Make sure the final score is set
                    const finalScore = document.getElementById('final-score');
                    if (finalScore) {
                        finalScore.textContent = `Score: ${score}`;
                    }
                } else {
                    console.error("Game over overlay not found!");
                }
            } catch (error) {
                console.error("Critical error showing game over screen:", error);
                
                // Direct attempt to show the game over overlay as last resort
                try {
                    document.getElementById('game-over-overlay').classList.add('visible');
                } catch (finalError) {
                    console.error("Failed to show game over screen:", finalError);
                }
            }
        }

        // Handle mini-game touch events
        function handleMiniGameTouch(e) {
            // Prevent default to avoid scrolling but don't prevent all other events
            e.preventDefault();
            
            const miniGameArea = document.getElementById('mini-game-area');
            if (!miniGameArea) {
                console.error("Mini-game area not found in touch handler!");
                return;
            }
            
            try {
                const rect = miniGameArea.getBoundingClientRect();
                
                // Process each touch point
                for (let i = 0; i < e.touches.length; i++) {
                    // Get touch coordinates
                    const touchX = e.touches[i].clientX - rect.left;
                    const touchY = e.touches[i].clientY - rect.top;
                    
                    console.log(`Touch detected at ${touchX}, ${touchY}`);
                    
                    // Check if any apple was touched
                    const apples = miniGameArea.querySelectorAll('.mini-game-apple');
                    let appleTouched = false;
                    
                    apples.forEach(apple => {
                        try {
                            if (apple.dataset.clickable !== 'true') {
                                return;
                            }
                            
                            const appleRect = apple.getBoundingClientRect();
                            const appleRelativeRect = {
                                left: appleRect.left - rect.left,
                                top: appleRect.top - rect.top,
                                right: appleRect.right - rect.left,
                                bottom: appleRect.bottom - rect.top
                            };
                            
                            // Increase hit area for better touch experience
                            const touchMargin = 10;
                            
                            if (touchX >= (appleRelativeRect.left - touchMargin) && 
                                touchX <= (appleRelativeRect.right + touchMargin) &&
                                touchY >= (appleRelativeRect.top - touchMargin) && 
                                touchY <= (appleRelativeRect.bottom + touchMargin)) {
                                
                                console.log("Apple touched!");
                                appleTouched = true;
                                
                                // Remove from parent to prevent double-clicking
                                if (apple.parentNode) {
                                    apple.parentNode.removeChild(apple);
                                } else {
                                    console.warn("Apple has no parent node when clicked");
                                }
                                
                                // Increase score
                                miniGameScore += 1;
                                const scoreElement = document.getElementById('mini-game-score');
                                if (scoreElement) {
                                    scoreElement.textContent = `Score: ${miniGameScore}`;
                                }
                                
                                // Create a new apple
                                try {
                                    createApple();
                                } catch (e) {
                                    console.error("Error creating new apple:", e);
                                }
                                
                                // Add visual effect
                                try {
                                    createParticles(3, '🍎', {
                                        x: e.touches[i].clientX,
                                        y: e.touches[i].clientY
                                    }, miniGameArea);
                                    
                                    // Play sound if available
                                    try {
                                        if (audioReady && eatSound) {
                                            eatSound.triggerAttackRelease('C6', '32n', Tone.now());
                                        }
                                    } catch (soundError) {
                                        console.error("Error playing apple sound:", soundError);
                                    }
                                } catch (particleError) {
                                    console.error("Error creating particles:", particleError);
                                }
                            }
                        } catch (appleError) {
                            console.error("Error handling apple touch:", appleError);
                        }
                    });
                }
            } catch (touchError) {
                console.error("Error handling touch:", touchError);
            }
        }

        // Update particle creation to work in different containers
        function createParticles(count, emoji, position = null, container = document.body) {
            // Default position to center of screen if not provided
            if (!position) {
                position = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
            }
            
            // Ensure position has x and y properties
            if (typeof position !== 'object' || position === null || typeof position.x !== 'number' || typeof position.y !== 'number') {
                console.warn("Invalid position for particles, using default position");
                position = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
            }
            
            for (let i = 0; i < count; i++) {
                try {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.textContent = emoji || '✨'; // Default emoji if none provided
                    
                    const x = position.x + (Math.random() * 40 - 20);
                    const y = position.y + (Math.random() * 40 - 20);
                    
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    
                    // Random direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    // Store velocity
                    particle.dataset.vx = vx;
                    particle.dataset.vy = vy;
                    
                    // Add to container using our safe append function
                    if (container && container.appendChild) {
                        safeAppendChild(container, particle);
                    } else {
                        safeAppendChild(document.body, particle);
                    }
                    
                    // Animate and remove after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 1000);
                    
                    // Move particles
                    let animTime = 0;
                    const moveParticle = (timestamp) => {
                        if (!particle.parentNode) return;
                        
                        if (!animTime) animTime = timestamp;
                        const elapsed = timestamp - animTime;
                        animTime = timestamp;
                        
                        const currentX = parseFloat(particle.style.left);
                        const currentY = parseFloat(particle.style.top);
                        const vx = parseFloat(particle.dataset.vx);
                        const vy = parseFloat(particle.dataset.vy) + 0.1; // Add gravity
                        
                        particle.style.left = `${currentX + vx}px`;
                        particle.style.top = `${currentY + vy}px`;
                        particle.dataset.vy = vy;
                        
                        // Fade out
                        particle.style.opacity = parseFloat(particle.style.opacity || 1) - 0.02;
                        
                        if (parseFloat(particle.style.opacity) > 0) {
                            requestAnimationFrame(moveParticle);
                        }
                    };
                    
                    requestAnimationFrame(moveParticle);
                } catch (e) {
                    console.error("Error creating particle:", e);
                }
            }
        }

        // Enhanced event listener for mobile to ensure mini-game works properly
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize achievements
            populateAchievements();
            
            // Make sure mini-game works on mobile
            const miniGameArea = document.getElementById('mini-game-area');
            const gameArea = document.getElementById('gameCanvas');
            
            // Improve rendering for high-DPI screens
            setupHighDPICanvas();
            
            // Set up mini-game buttons
            setupMiniGameControls();
            
            // Set up enhanced touch controls for mobile
            if (isTouchDevice()) {
                setupTouchControls();
            }
        });

        // Setup high-DPI canvas for better mobile display
        function setupHighDPICanvas() {
            const canvas = document.getElementById('gameCanvas');
            const dpr = window.devicePixelRatio || 1;
            
            // Get the original canvas dimensions from CSS
            const originalWidth = canvas.clientWidth;
            const originalHeight = canvas.clientHeight;
            
            // Set the canvas dimensions accounting for device pixel ratio
            canvas.width = originalWidth * dpr;
            canvas.height = originalHeight * dpr;
            
            // Scale the context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Set the CSS dimensions back to original
            canvas.style.width = `${originalWidth}px`;
            canvas.style.height = `${originalHeight}px`;
        }

        // Setup mini-game control buttons for better mobile experience
        function setupMiniGameControls() {
            const startButton = document.getElementById('mini-game-start');
            const skipButton = document.getElementById('mini-game-skip');
            
            // Make buttons larger and more visible for mobile
            if (isTouchDevice()) {
                if (startButton) {
                    startButton.style.fontSize = '18px';
                    startButton.style.padding = '15px 25px';
                    startButton.style.margin = '10px';
                }
                
                if (skipButton) {
                    skipButton.style.fontSize = '18px';
                    skipButton.style.padding = '15px 25px';
                    skipButton.style.margin = '10px';
                }
                
                // Make the mini-game container larger on mobile
                const miniGameContainer = document.getElementById('mini-game-container');
                if (miniGameContainer) {
                    miniGameContainer.style.fontSize = '1.2em';
                }
            }
            
            if (startButton) {
                startButton.addEventListener('click', function() {
                    try {
                        console.log("Start button clicked, current game state:", gameState);
                        
                        const miniGameArea = document.getElementById('mini-game-area');
                        if (!miniGameArea) {
                            console.error("Mini-game area not found!");
                            return;
                        }
                        
                        miniGameArea.focus();
                        
                        // Clear existing apples first
                        miniGameArea.querySelectorAll('.mini-game-apple').forEach(apple => {
                            try {
                                if (apple.parentNode) {
                                    apple.parentNode.removeChild(apple);
                                }
                            } catch (e) {
                                console.error("Error removing apple:", e);
                            }
                        });
                        
                        // Reset timer and score
                        miniGameTimer = 10;
                        miniGameScore = 0;
                        
                        // Update UI
                        const timerElement = document.getElementById('mini-game-timer');
                        const scoreElement = document.getElementById('mini-game-score');
                        
                        if (timerElement) {
                            timerElement.textContent = miniGameTimer;
                        }
                        
                        if (scoreElement) {
                            scoreElement.textContent = `Score: ${miniGameScore}`;
                        }
                        
                        // Clear any existing interval
                        if (miniGameInterval) {
                            clearInterval(miniGameInterval);
                        }
                        
                        // Create new apples
                        try {
                            createApples();
                            
                            // Enable clicking on apples
                            miniGameArea.querySelectorAll('.mini-game-apple').forEach(apple => {
                                apple.style.cursor = 'pointer';
                                apple.style.opacity = '1';
                                apple.dataset.clickable = 'true';
                            });
                        } catch (e) {
                            console.error("Error creating apples:", e);
                        }
                        
                        // Store whether we're coming from game over for later use
                        const isFromGameOver = gameState === 'gameover';
                        
                        // Start new timer interval
                        miniGameInterval = setInterval(() => {
                            try {
                                miniGameTimer--;
                                const timerElement = document.getElementById('mini-game-timer');
                                if (timerElement) {
                                    timerElement.textContent = miniGameTimer;
                                }
                                
                                if (miniGameTimer <= 0) {
                                    // Use the stored value from when the timer started
                                    endMiniGame(isFromGameOver);
                                }
                            } catch (e) {
                                console.error("Error in mini-game timer:", e);
                                clearInterval(miniGameInterval);
                                // Use the stored value from when the timer started
                                endMiniGame(isFromGameOver);
                            }
                        }, 1000);
                    } catch (e) {
                        console.error("Error handling start button click:", e);
                    }
                });
            }
            
            if (skipButton) {
                skipButton.addEventListener('click', function() {
                    try {
                        console.log("Skip button clicked, current game state:", gameState);
                        
                        // When skipping, set mini-game score to 0
                        miniGameScore = 0;
                        
                        // Always end the mini-game with isFromGameOver=true when skipping
                        // This ensures we go to game over screen
                        endMiniGame(true);
                        
                        // Force a transition to game over state after a short delay
                        setTimeout(() => {
                            console.log("Forcing transition to game over after skip");
                            switchState('gameover');
                        }, 300);
                    } catch (e) {
                        console.error("Error handling skip button click:", e);
                        // Last resort fallback to ensure game over is shown
                        switchState('gameover');
                    }
                });
            }
        }

        // Enhance touchscreen controls for better mobile experience
        function setupTouchControls() {
            if (!isTouchDevice()) return;
            
            // Make directional buttons more visible on mobile
            const controlButtons = document.querySelectorAll('.control-button');
            controlButtons.forEach(button => {
                button.style.opacity = '0.7';
                button.style.width = '60px';
                button.style.height = '60px';
            });
            
            // Make speed boost button more visible on mobile
            const speedBoostButton = document.getElementById('speed-boost-button');
            if (speedBoostButton) {
                speedBoostButton.style.width = '70px';
                speedBoostButton.style.height = '70px';
                speedBoostButton.style.fontSize = '16px';
            }
        }

        // Add this function to detect touch devices
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        }

        // Update init function to set up touch controls
        function initGame() {
            score = 0;
            isGameOver = false;
            lastUpdateTime = 0;
            accumulatedTime = 0;
            snake = [
                { x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }
            ];
            dx = 0;
            dy = 0;
            
            // Reset speed
            gameSpeed = initialGameSpeed;
            normalGameSpeed = gameSpeed;
            
            speedBoostActive = false;
            speedBoostCooldown = false;
            
            // Reset power-ups
            activePowerUp = null;
            powerUps = [];
            generatePowerUp();
            
            // Generate obstacles
            generateObstacles();
            
            // Generate portals
            generatePortals();
            
            // Generate initial food
            generateFood();
            
            // Set up mobile controls if on touch device
            if (isTouchDevice()) {
                setupTouchControls();
            }
            
            // Update UI
            updateUI();
            
            // Hide game over screen
            document.getElementById('game-over-overlay').classList.remove('visible');

            // Show game board
            switchState('playing');
            
            // Start game loop
            startGameLoop();
        }

        // Ensure we call setupTouchControls on window load in addition to init
        window.addEventListener('load', function() {
            // Initialize the high-DPI canvas
            setupHighDPICanvas();
            
            // Set up touch controls if on a touch device
            if (isTouchDevice()) {
                setupTouchControls();
            }
            
            // Initialize achievements if not already done
            if (!document.getElementById('achievements-list').children.length) {
                populateAchievements();
            }
            
            // Set up mini-game controls
            setupMiniGameControls();
        });

        // Extract power-up drawing to a separate function
        function drawPowerUps() {
            if (!powerUps || powerUps.length === 0) return;
            
            powerUps.forEach(powerUp => {
                const x = powerUp.x * gridSize;
                const y = powerUp.y * gridSize;
                const radius = gridSize / 2;
                
                // Draw colored circle
                ctx.fillStyle = powerUp.color;
                ctx.beginPath();
                ctx.arc(x + radius, y + radius, radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // Add a glowing effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x + radius * 0.7, y + radius * 0.7, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Add pulsing animation
                const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x + radius, y + radius, radius * 0.9 * pulseScale, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        // Ensure resources load properly with error handling
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize achievements with error handling
            try {
                populateAchievements();
            } catch (e) {
                console.error("Error initializing achievements:", e);
            }
            
            // Make sure mini-game works on mobile
            const miniGameArea = document.getElementById('mini-game-area');
            const gameCanvas = document.getElementById('gameCanvas');
            
            // Improve rendering for high-DPI screens
            try {
                if (gameCanvas) {
                    setupHighDPICanvas();
                }
            } catch (e) {
                console.error("Error setting up high-DPI canvas:", e);
            }
            
            // Set up mini-game buttons
            try {
                setupMiniGameControls();
            } catch (e) {
                console.error("Error setting up mini-game controls:", e);
            }
            
            // Set up enhanced touch controls for mobile
            try {
                if (isTouchDevice()) {
                    setupTouchControls();
                }
            } catch (e) {
                console.error("Error setting up touch controls:", e);
            }
            
            // Handle CORS errors for manifest and other resources
            window.addEventListener('error', function(e) {
                if (e.target && (e.target.tagName === 'LINK' || e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG')) {
                    console.warn('Resource loading error:', e.target.src || e.target.href);
                    // Don't let resource loading failures break the game
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        });

        // Fix HierarchyRequestError when appending elements
        function safeAppendChild(parent, child) {
            if (!parent || !child) return;
            
            try {
                // Check if the child is already a child of the parent
                if (!parent.contains(child)) {
                    parent.appendChild(child);
                }
            } catch (e) {
                console.error("Error appending child:", e);
            }
        }

        // Fix errors with favicon and other resources
        document.addEventListener('DOMContentLoaded', function() {
            // Handle resource loading errors
            window.addEventListener('error', function(e) {
                // Check if this is a resource loading error (not a JavaScript error)
                if (e.target && (e.target.tagName === 'LINK' || e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG')) {
                    // Prevent error from showing in console
                    e.preventDefault();
                    console.warn('Resource loading suppressed:', e.target.src || e.target.href);
                    return true;
                }
            }, true);
            
            // Create a data URI favicon if it fails to load
            const links = document.querySelectorAll('link[rel*="icon"]');
            links.forEach(link => {
                link.onerror = function() {
                    // Create a simple colored square as backup favicon
                    const canvas = document.createElement('canvas');
                    canvas.width = 16;
                    canvas.height = 16;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#5bbad5';
                    ctx.fillRect(0, 0, 16, 16);
                    link.href = canvas.toDataURL();
                };
            });
        });

        // Safe method to append a child to prevent hierarchy errors
        function safeAppendChild(parent, child) {
            try {
                // Check if parent and child exist
                if (!parent || !child) {
                    console.warn("Invalid parent or child element");
                    
                    // If parent doesn't exist but child does, try to add to body as fallback
                    if (!parent && child && document.body) {
                        document.body.appendChild(child);
                        return true;
                    }
                    return false;
                }
                
                // Check if child is already a child of parent (avoid duplicate append)
                if (child.parentNode === parent) {
                    return true;
                }
                
                // Try to append
                parent.appendChild(child);
                return true;
            } catch (e) {
                console.error("Error in safeAppendChild:", e);
                
                // Try to append to body as fallback
                try {
                    if (child && document.body) {
                        document.body.appendChild(child);
                        return true;
                    }
                } catch (innerError) {
                    console.error("Failed fallback append to body:", innerError);
                }
                
                return false;
            }
        }

        // Update DOM initialization code to use safeAppendChild
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Initialize achievements
                populateAchievements();
                
                // Improve rendering for high-DPI screens
                try {
                    setupHighDPICanvas();
                } catch (e) {
                    console.error("Error setting up high DPI canvas:", e);
                }
                
                // Set up mini-game buttons
                try {
                    setupMiniGameControls();
                } catch (e) {
                    console.error("Error setting up mini-game controls:", e);
                }
                
                // Set up enhanced touch controls for mobile
                if (isTouchDevice()) {
                    try {
                        setupTouchControls();
                    } catch (e) {
                        console.error("Error setting up touch controls:", e);
                    }
                }
                
                // Set global error handler for resources
                window.addEventListener('error', function(e) {
                    // Suppress console errors for resources that fail to load
                    if (e.target && (e.target.tagName === 'LINK' || e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG')) {
                        console.warn(`Resource failed to load: ${e.target.src || e.target.href}`);
                        e.preventDefault();
                        return true;
                    }
                }, true);
            } catch (e) {
                console.error("Error in DOMContentLoaded:", e);
            }
        });

        // Function to update the timer display
        function updateTimerDisplay() {
            // Only update timer if we're playing
            if (gameState !== 'playing') return;
            
            try {
                if (!gameStartTime) {
                    console.warn("gameStartTime not set, initializing now");
                    gameStartTime = Date.now();
                }
                
                // Calculate elapsed time
                const currentTime = Date.now();
                gameElapsedTime = currentTime - gameStartTime;
                const elapsedSeconds = Math.floor(gameElapsedTime / 1000);
                
                // Format time as MM:SS
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update timer display
                if (timerElement) {
                    timerElement.textContent = formattedTime;
                    
                    // Store raw seconds in data attribute for debugging
                    timerElement.setAttribute('data-seconds', elapsedSeconds);
                }
                
                // IMPORTANT: Update finalTimeScore continuously during gameplay
                // This ensures it's always available, even if handleGameOver doesn't run properly
                finalTimeScore = elapsedSeconds;
                
                // Store in window variable as backup
                window.lastKnownTimeScore = elapsedSeconds;
                
                // Log time every 10 seconds for debugging
                if (elapsedSeconds % 10 === 0 && elapsedSeconds > 0) {
                    console.log(`Game time: ${formattedTime} (${elapsedSeconds} seconds)`);
                }
            } catch (e) {
                console.error("Error updating timer:", e);
            }
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function createLocalLeaderboardFile() {
            try {
                const sampleData = {
                    success: true,
                    results: [
                        { name: "PLAYER1", score_value: 100, time_score: 120 },
                        { name: "PLAYER2", score_value: 80, time_score: 150 },
                        { name: "PLAYER3", score_value: 60, time_score: 200 },
                        { name: "PLAYER4", score_value: 40, time_score: 180 },
                        { name: "PLAYER5", score_value: 20, time_score: 220 }
                    ]
                };
                
                // Create a downloadable JSON file
                const dataStr = JSON.stringify(sampleData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = 'leaderboard.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                console.log("Sample leaderboard.json file created. Please place it in your server root directory.");
            } catch (e) {
                console.error("Error creating sample leaderboard file:", e);
            }
        }

        // --- Initialization Functions --- (Audio unchanged)
        function initAudio() {
            if (audioReady || typeof Tone === 'undefined') {
                return;
            }
            
            try {
                eatSound = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
                }).toDestination();
                
                gameOverSound = new Tone.NoiseSynth({
                    noise: { type: 'brown' },
                    envelope: { attack: 0.05, decay: 0.5, sustain: 0, release: 0.2 }
                }).toDestination();
                
                if (Tone.context.state !== 'running') {
                    if (!window.toneStartedPromise) {
                        window.toneStartedPromise = Tone.start();
                    }
                    
                    window.toneStartedPromise.then(() => {
                        audioReady = true;
                    }).catch(e => {
                        console.error("Tone.start() failed:", e);
                        audioReady = false;
                    }).finally(() => {
                        window.toneStartedPromise = null;
                    });
                } else {
                    audioReady = true;
                }
            } catch (e) {
                console.error("Error setting up Tone.js sounds:", e);
                audioReady = false;
            }
        }

        function playEatSound() {
            if (audioReady && eatSound && Tone.context.state === 'running') {
                try {
                    eatSound.triggerAttackRelease('C5', '8n', Tone.now());
                } catch (e) {
                    console.error("Error playing eat sound:", e);
                }
            }
        }

        function playGameOverSound() {
            if (audioReady && gameOverSound && Tone.context.state === 'running') {
                try {
                    gameOverSound.triggerAttackRelease('1n', Tone.now());
                } catch (e) {
                    console.error("Error playing game over sound:", e);
                }
            }
        }

        // Add a forcibly show game over function that can be called as a last resort
        function forceGameOverScreen() {
            console.log("Forcing game over screen to appear");
            
            try {
                // Set correct game state
                isGameOver = true;
                gameState = 'gameover';
                
                // Cancel any ongoing animation or timers
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                if (miniGameInterval) {
                    clearInterval(miniGameInterval);
                    miniGameInterval = null;
                }
                
                // Reset mini-game state
                miniGameActive = false;
                const miniGameContainer = document.getElementById('mini-game-container');
                if (miniGameContainer) {
                    miniGameContainer.classList.remove('active');
                }
                
                // Clear any global variables
                window.miniGameIsFromGameOver = undefined;
                window.isLeaderboardFunctionCalling = false;
                
                // Hide ALL overlays first to ensure clean state
                document.querySelectorAll('.overlay').forEach(overlay => {
                    overlay.classList.remove('visible');
                });
                
                // Update final score display
                if (finalScoreElement) {
                    finalScoreElement.textContent = `Score: ${score} | Time: ${formatTime(finalTimeScore)}`;
                }
                
                // Show game over overlay
                const gameOverOverlay = document.getElementById('game-over-overlay');
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('visible');
                    console.log("Game over overlay made visible");
                } else {
                    console.error("CRITICAL: Game over overlay element not found!");
                }
                
                // Notify the user
                showMessage("Game complete! Check your score.", 3000);
                
                // Try to load leaderboard data for player rank
                try {
                    loadLeaderboard().then(() => {
                        displayPlayerRank();
                    }).catch(e => console.error("Error loading leaderboard:", e));
                } catch (e) {
                    console.error("Error loading leaderboard:", e);
                }
                
                return true;
            } catch (error) {
                console.error("Critical error in forceGameOverScreen:", error);
                
                // Last resort - direct DOM manipulation
                try {
                    document.querySelectorAll('.overlay').forEach(el => el.classList.remove('visible'));
                    const gameOver = document.getElementById('game-over-overlay');
                    if (gameOver) gameOver.classList.add('visible');
                } catch (finalError) {
                    console.error("FATAL ERROR showing game over screen:", finalError);
                }
                
                return false;
            }
        }

        // Modify the endMiniGame function to call the force function if needed
        function endMiniGame(isFromGameOver = false) {
            try {
                console.log("Ending mini-game, cleaning up resources...");
                
                // Use the stored global variable if available, otherwise use the parameter
                // This ensures consistency between start and end of mini-game
                isFromGameOver = window.miniGameIsFromGameOver || isFromGameOver;
                console.log(`endMiniGame called with isFromGameOver: ${isFromGameOver}`);
                
                if (miniGameInterval) {
                    clearInterval(miniGameInterval);
                    miniGameInterval = null;
                }
                
                const miniGameContainer = document.getElementById('mini-game-container');
                if (miniGameContainer) {
                    miniGameContainer.classList.remove('active');
                }
                
                miniGameActive = false;
                
                // Award points based on mini-game score
                const pointsEarned = miniGameScore * 2;
                score += pointsEarned;
                updateScoreDisplay();
                
                // Update achievement for mini-games
                try {
                    updateAchievement('apple_collector', miniGameScore);
                    updateAchievement('mini_game_master', miniGameScore);
                } catch (e) {
                    console.error("Error updating achievements:", e);
                }
                
                // Show celebration if player achieved a high mini-game score
                if (miniGameScore >= 15) {
                    try {
                        createParticles(10, '🎮', {
                            x: window.innerWidth / 2,
                            y: window.innerHeight / 2
                        });
                        playAchievementSound();
                    } catch (e) {
                        console.error("Error creating celebration:", e);
                    }
                }
                
                showMessage(`Mini-game complete! Earned ${pointsEarned} points!`, 2000);
                
                // Save the final score to API again after mini-game points are added
                if (username && score > 0) {
                    try {
                        // Use the stored finalTimeScore from window or from the regular variable
                        const currentTimeScore = window.finalSnakeTimeScore || finalTimeScore;
                        
                        console.log(`Saving final score to API after mini-game: ${username}, ${score}, ${currentTimeScore}`);
                        
                        // Verify time score is a valid number
                        if (isNaN(currentTimeScore) || typeof currentTimeScore !== 'number') {
                            console.warn("Invalid time score detected in endMiniGame, using current game time");
                            finalTimeScore = Math.floor((Date.now() - gameStartTime) / 1000);
                        } else {
                            finalTimeScore = currentTimeScore;
                        }
                        
                        console.log(`Validated time score: ${finalTimeScore}`);
                        
                        saveScoreToAPI(username, score, finalTimeScore)
                            .then(() => {
                                console.log("Score saved successfully after mini-game");
                            })
                            .catch(err => {
                                console.error("Error saving score after mini-game:", err);
                            });
                    } catch (e) {
                        console.error("Error saving score after mini-game:", e);
                    }
                }
                
                // Make sure we always show the game over screen after a short delay
                // This is important to prevent the game from getting stuck
                setTimeout(() => {
                    console.log(`Mini-game ended, isFromGameOver: ${isFromGameOver}`);
                    
                    if (isFromGameOver) {
                        // First attempt using normal flow
                        console.log("Switching to gameover state");
                        
                        // Force game over state
                        isGameOver = true;
                        gameState = 'gameover';
                        
                        // Update the final score display to include mini-game points
                        if (finalScoreElement) {
                            finalScoreElement.textContent = `Score: ${score} | Time: ${formatTime(finalTimeScore)}`;
                        }
                        
                        // Clear any stored flags
                        window.miniGameIsFromGameOver = undefined;
                        
                        // Hide all overlays first to ensure a clean state
                        document.querySelectorAll('.overlay').forEach(overlay => overlay.classList.remove('visible'));
                        
                        // Hide the mini-game container explicitly
                        const miniGameContainer = document.getElementById('mini-game-container');
                        if (miniGameContainer) {
                            miniGameContainer.classList.remove('active');
                        }
                        
                        // Try the normal switchState method
                        switchState('gameover');
                        
                        // Set a backup timer to force the game over screen if it doesn't appear
                        setTimeout(() => {
                            const gameOverOverlay = document.getElementById('game-over-overlay');
                            const isOverlayVisible = gameOverOverlay && gameOverOverlay.classList.contains('visible');
                            
                            if (!isOverlayVisible) {
                                console.warn("Game over screen did not appear within timeout! Forcing it...");
                                forceGameOverScreen();
                            } else {
                                console.log("Game over screen is visible, no need to force it");
                            }
                        }, 1500);
                        
                        // Update high score if needed
                        try {
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('snakeHighScore', score);
                                showMessage("New High Score! 🎉", 3000);
                            }
                        } catch (e) {
                            console.error("Error updating high score:", e);
                        }
                    } else if (gameState === 'playing') {
                        // Resume main game if was playing
                        startGameLoop();
                    } else {
                        // Fallback in case we're in an unknown state
                        console.warn("Unknown game state when ending mini-game:", gameState);
                        switchState('gameover');
                    }
                }, 1000); // Longer delay to ensure messages are visible and transition is smoother
            } catch (e) {
                console.error("Error in endMiniGame:", e);
                // Ultimate fallback - force the game over screen
                forceGameOverScreen();
            }
        }
    </script>

    <!-- Add mobile controls and portal fixes -->
    <script src="fix-mobile-controls.js"></script>

    <!-- Enhanced error handling for resources -->
    <script>
        // Global error handler for resource loading
        window.addEventListener('error', function(e) {
            // Suppress console errors for resources that fail to load
            if (e.target.tagName === 'LINK' || e.target.tagName === 'SCRIPT' || e.target.tagName === 'IMG') {
                console.warn(`Resource failed to load: ${e.target.src || e.target.href}`);
                e.preventDefault();
            }
        }, true);
    </script>

    <!-- Add event listeners for game controls -->
    <script>
        // Add event listeners for game controls
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Setting up game event listeners...");
            
            // Start game button
            const startGameButton = document.getElementById('start-game-button');
            if (startGameButton) {
                console.log("Found start game button, adding event listener");
                startGameButton.addEventListener('click', function() {
                    console.log("Start button clicked");
                    username = usernameInput.value.trim() || 'AAA';
                    console.log(`Starting game with username: ${username}`);
                    
                    // Reset the game variables
                    initGameVariables();
                    
                    // Set up game state
                    gameStartTime = Date.now();
                    
                    console.log("Switching state to playing");
                    switchState('playing');
                    
                    // Start the game loop
                    if (!animationFrameId) {
                        console.log("Starting game loop");
                        animationFrameId = requestAnimationFrame(gameLoop);
                    }
                });
            } else {
                console.error("Start game button not found!");
            }
            
            // Restart game button
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', function() {
                    console.log("Restart button clicked");
                    
                    // Reset the game variables
                    initGameVariables();
                    
                    // Set up game state
                    gameStartTime = Date.now();
                    
                    console.log("Switching state to playing from restart");
                    switchState('playing');
                    
                    // Start the game loop
                    if (!animationFrameId) {
                        console.log("Starting game loop from restart");
                        animationFrameId = requestAnimationFrame(gameLoop);
                    }
                });
            }
            
            // Leaderboard buttons
            const showLeaderboardButtonStart = document.getElementById('show-leaderboard-button-start');
            if (showLeaderboardButtonStart) {
                showLeaderboardButtonStart.addEventListener('click', displayLeaderboard);
            }
            
            const showLeaderboardButtonGameOver = document.getElementById('show-leaderboard-button-gameover');
            if (showLeaderboardButtonGameOver) {
                showLeaderboardButtonGameOver.addEventListener('click', displayLeaderboard);
            }
            
            // Close leaderboard button
            const closeLeaderboardButton = document.getElementById('close-leaderboard-button');
            if (closeLeaderboardButton) {
                closeLeaderboardButton.addEventListener('click', function() {
                    // Determine which state to return to
                    const prevState = (gameState === 'gameover') ? 'gameover' : 'username';
                    switchState(prevState);
                });
            }
            
            // Username input submission
            const usernameInput = document.getElementById('username-input');
            if (usernameInput) {
                usernameInput.addEventListener('keyup', function(e) {
                    if (e.key === 'Enter') {
                        console.log("Enter pressed in username input");
                        username = usernameInput.value.trim() || 'AAA';
                        switchState('playing');
                    }
                });
            }
        });
    </script>
</body>
</html>
